You are a full stack web developer. You need to make a change for the existing solution. This solution is a betting application built using AWS. It uses reactjs for frontend and graphql to connect to backend. The backend is built using Appsync that is connected to lambda functions that process queries and mutations. Lambda functions emit messages to Amazon EventBridge which are being populated to SQS and picked up by other lambda functions later on. The solution is built using AWS SAM and contains CloudFormation templates for all of its components. Lambda functions are also covered by Amazon X-Ray. 
I will provide you a code for all key parts for one of components - Live Market service. This service updates the events on a website. These events are not re-generated, but just updated via this service to change the odds for same events in DynamoDB table. 
Frontend component for this service renders a table with set of buttons: 1/ "Suspend" and "Close" for each outcome 2/ "End Event" for the whole event. 
"End event" button is currently operational, however "suspend" and "close" - not. "Suspend" should put the event to suspended state, however it should be possible to unsuspend the event. 

What should happen when "suspend" is clicked on frontend:
1. Button should change its text to "unsuspend"
2. Event outcome should be marked as "suspended" in dynamoDB table.

What should happen on a backend:
1. Event should have additional subitem "marketstatus" in dynamodb. This subitem should have following schema: "marketstatus": { "name": "",  "status": ""}. 
Example schema for a single event:
{
    "eventid": "xxxx",
    ... rest of the fields
    "marketstatus": [{
        "name": "Home",
        "status": "Suspended"
    },
    {
        "name": "Draw",
        "status": "Active"
    },
    {
        "name": "Away",
        "status": "Close"
    }
    ]
}
4. When button "suspend" is clicked on frontend, it should trigger update to corresponding market so that it changes the status to "suspended".
5. When button "unsuspend" is clicked on frontend, it should trigger update to corresponding market so that it changes the status to "active".
6. When button "close" is clicked on frontend, it should trigger update to corresponding market so that it changes the status to "closed".
7. Add all required code to all required files. Including graphql schema, cloudformation templates, and frontend.
8. Provide instructions how to create all required lambda functions

Your task is to provide complete explanation including all required code changes in a step-by-step scenario. You have to include code file with change. I will prompt you with "next step" once previous one is done. 
Begin your answer with a first step.

<code filename="EventOdds.jsx" description="renders events and odds on frontend and renders close and suspend buttons">
import { Typography, Card, Button, Box, ButtonGroup } from "@mui/material";
import CancelIcon from '@mui/icons-material/Cancel';
import { DataGrid } from "@mui/x-data-grid";
import { useEvents, useFinishEvent } from "../../hooks/useEvents";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const renderOdds = (params) => {

  return (
    <ButtonGroup>
        <Button
        variant="outlined"
        size="small"
        onClick={() => {
            suspendMarket({ event: params.row.eventId, market: params.field });
        }}
        >
            Suspend
        </Button>
        <Button         
        variant="outlined"
        size="small"
        color="error"
        onClick={() => {
            closeMarket({ event: params.row.eventId, market: params.field });
        }}>
            Close
        </Button>
    </ButtonGroup>
  );
};

const renderActions = (params) => {
    return (
        <ButtonGroup>
            <Button
            size="small"
            startIcon={<CancelIcon />}
            variant="contained"
            onClick={() => {
              EventOdds.handleFinishEvent(params.row.eventId, 'homeWin')
            }}>
                End Event
            </Button>
        </ButtonGroup>
    )
    
}

const suspendMarket = ({ event, market}) => {
    console.log(`suspending market '${market}' (${event})`);
}

const closeMarket = ({ event, market}) => {
    console.log(`closing market '${market}' (${event})`);
}


export const EventOdds = () => {
  const { data: events, isLoading: loadingEvents } = useEvents();
  const { mutateAsync: triggerFinishEvent } = useFinishEvent();
  const handleTriggerFinishEvent = (eventId, outcome) => triggerFinishEvent(
    { data: { eventId: eventId, outcome: outcome, eventStatus: 'finished'  } }
  );
  const handleFinishEvent = async (eventId, outcome) => {
    console.log('closing event', {'eventId': eventId, 'outcome': outcome})
    handleTriggerFinishEvent(eventId, outcome);
    console.log("Event finished. Good luck settling!");
  };
  
  
    
  if (loadingEvents) return <Typography>Loading...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      sortable: false,
      flex: 1,
      renderCell: ({ row }) => (
        <Box>
          <Typography variant={"subtitle2"} fontWeight={600}>
            {row.home} vs {row.away}
          </Typography>
          <Typography variant={"caption"}>
            Starts at {new Date(row.start).toLocaleString("en-GB", dateOptions)}
          </Typography>
        </Box>
      ),
    },
    {
      field: "homeOdds",
      headerName: "Home Win",
      flex: 1,
      sortable: false,
      align: "center",
      headerAlign: "center",
      renderCell: renderOdds,
    },
    {
      field: "awayOdds",
      headerName: "Away Win",
      flex: 1,
      sortable: false,
      align: "center",
      headerAlign: "center",
      renderCell: renderOdds,
    },
    {
      field: "drawOdds",
      headerName: "Draw",
      flex: 1,
      sortable: false,
      align: "center",
      headerAlign: "center",
      renderCell: renderOdds,
    },
    {
        field: "eventActions",
        headerName: "Actions",
        flex: 1,
        align: "center",
        sortable: false,
        headerAlign: "center",
        renderCell: (params) => {
          return (
            <ButtonGroup>
                <Button
                size="small"
                variant="contained"
                startIcon={<CancelIcon />}
                onClick={() => {
                  handleFinishEvent(params.row.eventId, 'homeWin')
                }}>
                    End Event
                </Button>
            </ButtonGroup>
        )
       }
    }
  ];

  

  return (
    <Card style={{ "maxWidth": '1600px'}}>
      <DataGrid
        rows={events}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 10,
            },
          },
          sorting: {
            sortModel: [{ field: "updatedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.eventId}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default EventOdds;

</code>

<code filename="hooks/useEvents.jsx">
import { useEffect } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { API, graphqlOperation } from "aws-amplify";
import { Auth } from "aws-amplify";

import * as queries from "../graphql/queries.js";
import * as mutations from "../graphql/mutations.js";
import * as subscriptions from "../graphql/subscriptions.js";

export const CACHE_PATH = "events";

export const useEvents = (config = {}) => {
  const queryClient = useQueryClient();
  const dateKeys = ["start", "end", "updatedAt"];
  const deserializer = deserializeEvent([dateKeys]);
  useEffect(() => {
    const sub = API.graphql(
      graphqlOperation(subscriptions.updatedEventOdds)
    ).subscribe({
      next: ({ provider, value }) => {
        queryClient.setQueryData([CACHE_PATH], (oldData) => {
          const newEvent = deserializer(value.data.updatedEventOdds);
          const newItems = oldData.filter(
            (e) => e.eventId !== newEvent.eventId
          );
          newItems.push(newEvent);
          return newItems;
        });
      },
      error: (error) => console.warn(error),
    });

    return () => sub.unsubscribe();
  }, []);

  return useQuery(
    [CACHE_PATH],
    () =>
      API.graphql({ query: queries.getEvents }).then((res) => {
        const result = res?.data?.getEvents?.items ?? [];
        return result.map(deserializer);
      }),
    {
      refetchInterval: 0,
      useErrorBoundary: false,
      enabled: true,
      ...config,
    }
  );
};

export const useFinishEvent = (config = {}) => {
  const queryClient = useQueryClient();
  return useMutation(
    ({ data }) =>
      API.graphql({
        query: mutations.triggerFinishEvent,
        variables: { input: data },
      }),
    {
      onSuccess: () => {
        return queryClient.invalidateQueries([CACHE_PATH]);
      },
      onError: (err, { id, dataType }) => {
        console.error(err);
      },
      ...config,
    }
  );
};

const deserializeEvent = (dateKeys) => (event) => {
  return Object.fromEntries(
    Object.entries(event).map(([k, v]) =>
      dateKeys.includes(k) ? [k, new Date(v)] : [k, v]
    )
  );
};

const hooks = {
  useEvents: useEvents,
  useFinishEvent: useFinishEvent
};

export default hooks;
</code>

<code filename="providers/BetSlipContext">
import { useContext, createContext } from "react";

export const betSlipContext = createContext([false, () => {}]);

export const useBetSlip = () => {
  return useContext(betSlipContext);
};

export default {
  useBetSlip,
  betSlipContext,
};
</code>

<code filename="graphql/queries.js">
export const getEvents = /* GraphQL */ `
  query GetEvents($startKey: String) {
    getEvents(startKey: $startKey) {
      ... on EventList {
        items {
          eventId
          homeOdds
          awayOdds
          drawOdds
          home
          away
          start
          end
          updatedAt
        }
        nextToken
      }
      ... on Error {
        message
      }
    }
  }
`;
export const getBets = /* GraphQL */ `
  query GetEvents($startKey: String) {
    getBets(startKey: $startKey) {
      ... on BetList {
        __typename
        items {
          betId
          odds
          outcome
          placedAt
          betStatus
          event {
            away
            awayOdds
            drawOdds
            end
            eventId
            home
            homeOdds
            start
            updatedAt
            eventStatus
          }
        }
        nextToken
      }
      ... on Error {
        message
      }
    }
  }
`;
export const getWallet = /* GraphQL */ `
  query GetWallet {
    getWallet {
      ... on Wallet {
        __typename
        userId
        balance
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
export const getEvent = /* GraphQL */ `
  query GetEvent($eventId: ID!) {
    getEvent(eventId: $eventId) {
      ... on Event {
        __typename
        away
        awayOdds
        drawOdds
        end
        eventId
        home
        homeOdds
        start
        updatedAt
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const getPingInfo = /* GraphQL */ `
  query GetPingInfo {
    getPingInfo {
      ... on PingInfo {
        __typename
        items {
          pingLocation
          pingLatency
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
</code>

<code filename="graphql/mutations.js">
export const createWallet = /* GraphQL */ `
  mutation CreateWallet($input: CreateWalletInput) {
    createWallet(input: $input) {
      ... on Wallet {
        __typename
        userId
        balance
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
export const withdrawFunds = /* GraphQL */ `
  mutation WithdrawFunds($input: WithdrawOrDepositInput) {
    withdrawFunds(input: $input) {
      ... on Wallet {
        __typename
        userId
        balance
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
export const depositFunds = /* GraphQL */ `
  mutation DepositFunds($input: WithdrawOrDepositInput) {
    depositFunds(input: $input) {
      ... on Wallet {
        __typename
        userId
        balance
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
export const createBets = /* GraphQL */ `
  mutation CreateBets($input: CreateBetsInput) {
    createBets(input: $input) {
      ... on BetList {
        __typename
        nextToken
        items {
          betId
          amount
          outcome
          odds
          event {
            away
            awayOdds
            drawOdds
            end
            eventId
            home
            homeOdds
            start
            updatedAt
          }
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const lockUser = /* GraphQL */ `
  mutation LockUser($input: LockUserInput) {
    lockUser(input: $input) {
      ... on User {
        __typename
        userId
        isLocked
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const triggerFinishEvent = /* GraphQL */ `
  mutation TriggerFinishEvent($input: FinishEventInput) {
    triggerFinishEvent(input: $input) {
      ... on Event {
        __typename
        eventId
        eventStatus
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const sendChatbotMessage = /* GraphQL */ `
  mutation SendChatbotMessage($input: ChatbotMessageInput) {
    sendChatbotMessage(input: $input) {
      ... on ChatbotResponse {
        __typename
        completion
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
</code>
<code filename="graphql/subscriptions.js">
/* eslint-disable */
// this is an auto generated file. This will be overwritten

export const updatedEventOdds = /* GraphQL */ `
  subscription UpdatedEventOdds {
    updatedEventOdds {
      ... on Event {
        eventId
        homeOdds
        awayOdds
        drawOdds
        home
        away
        start
        end
        updatedAt
      }
      ... on Error {
        message
      }
    }
  }
`;

export const updatedSystemEvents = /* GraphQL */ `
  subscription UpdatedSystemEvents {
    updatedSystemEvents {
      ... on SystemEvent {
        source
        detailType
        detail
      }
      ... on Error {
        message
      }
    }
  }
`;
export const updatedUserStatus = /* GraphQL */ `
  subscription UpdatedUserStatus {
    updatedUserStatus {
      ... on User {
        userId
        isLocked
      }
      ... on Error {
        message
      }
    }
  }
`;
</code>
<code filename="schema.graphql">
type Wallet @aws_cognito_user_pools @aws_iam {
  userId: ID!
  balance: Float!
}

type PingInfo @aws_cognito_user_pools @aws_iam {
  items: [PingInfoItem]!
}

type PingInfoItem @aws_cognito_user_pools @aws_iam {
  pingLocation: String!
  pingLatency: Float!
}

type ChatbotResponse @aws_cognito_user_pools @aws_iam {
  completion: String!
}

type Event @aws_cognito_user_pools @aws_iam {
  eventId: ID!
  homeOdds: String!
  awayOdds: String!
  drawOdds: String!
  home: String!
  away: String!
  start: AWSDateTime!
  end: AWSDateTime!
  updatedAt: AWSDateTime!
  eventStatus: EventStatus!
  outcome: String
}

type EventList @aws_cognito_user_pools @aws_iam {
  items: [Event]!
  nextToken: String
}

type Bet @aws_cognito_user_pools @aws_iam {
  betId: ID!
  event: Event!
  outcome: EventOutcome!
  odds: String!
  amount: Float!
  placedAt: AWSDateTime!
  userId: ID!
  betStatus: String!
}

type BetList @aws_cognito_user_pools @aws_iam {
  items: [Bet]!
  nextToken: String
}

type User @aws_cognito_user_pools @aws_iam {
  userId: ID!
  isLocked: String!
}

type SystemEvent @aws_cognito_user_pools @aws_iam {
  source: String!
  detailType: String
  detail: String
}

 enum EventOutcome {
    homeWin
    awayWin
    draw
 }

 enum EventStatus {
    running
    finished
    settled
 }

interface Error {
  message: String!
}

type InsufficientFundsError implements Error @aws_cognito_user_pools @aws_iam {
  message: String!
}

type NotFoundError implements Error @aws_cognito_user_pools @aws_iam {
  message: String!
}

type InputError implements Error @aws_cognito_user_pools @aws_iam {
  message: String!
}

type UnknownError implements Error @aws_cognito_user_pools @aws_iam {
  message: String!
}

union WalletResult = Wallet | InsufficientFundsError | NotFoundError | InputError | UnknownError
union PingInfoResult = PingInfo | InsufficientFundsError | NotFoundError | InputError | UnknownError
union EventResult = Event | NotFoundError | InputError | UnknownError
union EventsResult = EventList | NotFoundError | InputError | UnknownError
union BetsResult = BetList | InsufficientFundsError | NotFoundError | InputError | UnknownError
union SystemEventResult =  SystemEvent | NotFoundError | InputError | UnknownError
union UserResult = User | NotFoundError | InputError | UnknownError
union ChatbotResult = ChatbotResponse | NotFoundError | InputError | UnknownError


input CreateWalletInput {
  userId: ID!
}

input WithdrawOrDepositInput {
  amount: Float!
}

input DeductFundsInput {
  userId: ID!
  amount: Float!
}

input UpdateEventOddsInput {
  eventId: ID!
  homeOdds: String!
  awayOdds: String!
  drawOdds: String!
}

input FinishEventInput {
  eventId: ID!
  eventStatus: String!
  outcome: String!
}

input BetRequest {
  eventId: ID!
  outcome: EventOutcome
  odds: String!
  amount: Float!
}

input SystemEventInput {
  source: String!
  detailType: String
  detail: String
}

input CreateBetsInput {
  bets: [BetRequest]!
}

input LockUserInput {
  userId: ID!
  isLocked: String!
}

input LockBetsForEventInput {
  eventId: ID!
}

input ChatbotMessageInput {
  prompt: String!
}

type Query {
  getEvents(startKey: String): EventsResult @aws_cognito_user_pools @aws_iam
  getWallet: WalletResult @aws_cognito_user_pools
  getPingInfo: PingInfoResult @aws_cognito_user_pools
  getBets(startKey: String): BetsResult @aws_cognito_user_pools
  getWalletByUserId(userId: ID!): WalletResult @aws_iam
  getEvent(eventId: ID!, timestamp: Float): EventResult @aws_iam @aws_cognito_user_pools
}

type Mutation {
  createWallet(input: CreateWalletInput): WalletResult @aws_iam
  depositFunds(input: WithdrawOrDepositInput): WalletResult @aws_cognito_user_pools @aws_iam
  sendChatbotMessage(input: ChatbotMessageInput): ChatbotResult @aws_cognito_user_pools @aws_iam
  updateEventOdds(input: UpdateEventOddsInput): EventResult @aws_iam
  # finishEvent is a synchronous method to update event in data storage
  # Currently not used
  finishEvent(input: FinishEventInput): EventResult @aws_iam
  # triggerFinishEvent is an asynchronous method
  # used only to re-raise event into service bus.
  triggerFinishEvent(input: FinishEventInput): EventResult @aws_cognito_user_pools
  withdrawFunds(input: WithdrawOrDepositInput): WalletResult @aws_cognito_user_pools @aws_iam
  deductFunds(input: DeductFundsInput): WalletResult @aws_iam
  createBets(input: CreateBetsInput): BetsResult @aws_cognito_user_pools
  addSystemEvent(input: SystemEventInput): SystemEventResult @aws_iam
  lockUser(input: LockUserInput): UserResult @aws_cognito_user_pools
  lockBetsForEvent(input: LockBetsForEventInput): BetsResult @aws_iam
}

type Subscription {
  updatedEventOdds: EventResult @aws_subscribe(mutations: ["updateEventOdds"])
  finishEvent: EventResult @aws_subscribe(mutations: ["finishEvent"])
  updatedSystemEvents: SystemEventResult @aws_subscribe(mutations: ["addSystemEvent"])
  updatedUserStatus: UserResult @aws_subscribe(mutations: ["lockUser"])
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
</code>
<code filename="livemarket-service.yaml">
AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::Serverless-2016-10-31

Globals:

  Function:
    Runtime: python3.9
    Tracing: Active
    Layers:
      - !Sub arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:32
    Environment:
      Variables:
        POWERTOOLS_SERVICE_NAME: livemarket

Parameters:

  AppSyncApiId:
    Type: String

  AppSyncApiUrl:
    Type: String

  EventBus:
    Type: String

  AppSyncLambdaLayer:
    Type: String

Resources:

  LiveMarketDataStore:
    Type: AWS::DynamoDB::Table
    Properties:
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: eventId
          AttributeType: S
      KeySchema:
        - AttributeName: eventId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST

  LiveMarketHistoryStore:
    Type: AWS::DynamoDB::Table
    Properties:
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: eventId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: eventId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: expiry
        Enabled: true

  SeedLambda:
    Type: AWS::Serverless::Function
    Description: Custom resource for seeding dynamo
    Properties:
      Handler: app.lambda_handler
      CodeUri: ../lambda/livemarket/seed/
      Timeout: 30
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref LiveMarketDataStore
      Environment:
        Variables:
          DB_TABLE: !Ref LiveMarketDataStore

  # This populates some initial data in our events table
  LiveMarketDataSeed:
    Type: Custom::Seed
    Properties:
      ServiceToken: !GetAtt SeedLambda.Arn

  SQSQueue:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 60
      RedrivePolicy:
        maxReceiveCount: 2
        deadLetterTargetArn: !GetAtt DLQ.Arn

  DLQ:
    Type: AWS::SQS::Queue

  EventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "Live market receiver for trading events"
      EventBusName: !Ref EventBus
      EventPattern:
        source:
          - "com.trading"
          - "com.thirdparty"
      Targets:
        - Arn: !GetAtt SQSQueue.Arn
          Id: SQSqueue

  EventBridgeToToSqsPolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: events.amazonaws.com
          Action: sqs:SendMessage
          Resource:  !GetAtt SQSQueue.Arn
          Condition:
            StringEqualsIfExists:
              aws:SourceAccount: !Ref AWS::AccountId
      Queues:
        - Ref: SQSQueue

  LiveMarketBatchFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: app.lambda_handler
      CodeUri: ../lambda/livemarket/receiver/
      Description: Lambda for receiving events for this service
      Timeout: 10
      MemorySize: 256
      Layers:
        - !Ref AppSyncLambdaLayer
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt SQSQueue.Arn
            BatchSize: 10
            FunctionResponseTypes:
              - ReportBatchItemFailures
      Policies:
        - EventBridgePutEventsPolicy:
            EventBusName: !Ref EventBus
        - Statement:
            - Effect: Allow
              Action:
                - appsync:GraphQL
              Resource:
                - !Sub arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${AppSyncApiId}/types/Mutation/fields/updateEventOdds
                - !Sub arn:aws:appsync:${AWS::Region}:${AWS::AccountId}:apis/${AppSyncApiId}/types/Mutation/fields/finishEvent
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          APPSYNC_URL: !Ref AppSyncApiUrl
          EVENT_BUS: !Ref EventBus

  LiveMarketResolverFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: app.lambda_handler
      CodeUri: ../lambda/livemarket/resolvers/
      Description: Lambda for AppSync resolvers
      Timeout: 10
      MemorySize: 256
      Policies:
        - EventBridgePutEventsPolicy:
            EventBusName: !Ref EventBus
        - DynamoDBCrudPolicy:
            TableName: !Ref LiveMarketDataStore
        - DynamoDBCrudPolicy:
            TableName: !Ref LiveMarketHistoryStore
      Environment:
        Variables:
          DB_TABLE: !Ref LiveMarketDataStore
          DB_HISTORY_TABLE: !Ref LiveMarketHistoryStore
          ACCOUNT_ID: !Ref AWS::AccountId
          APPSYNC_API_ID: !Ref AppSyncApiId
          DB_HISTORY_RETENTION: 3600
          EVENT_BUS: !Ref EventBus

  LiveMarketAppSyncRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - appsync.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-AppSyncRole
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt LiveMarketResolverFunction.Arn

  LiveMarketLambdaDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !Ref AppSyncApiId
      Name: LiveMarket_Lambda_Source
      Description: Live Market Lambda AppSync Data Source
      Type: AWS_LAMBDA
      ServiceRoleArn: !GetAtt LiveMarketAppSyncRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt LiveMarketResolverFunction.Arn

  GetEventsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !Ref AppSyncApiId
      TypeName: Query
      FieldName: getEvents
      DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name

  GetEventResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !Ref AppSyncApiId
      TypeName: Query
      FieldName: getEvent
      DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name

  UpdateEventOddsResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !Ref AppSyncApiId
      TypeName: Mutation
      FieldName: updateEventOdds
      DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name

  FinishEventResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !Ref AppSyncApiId
      TypeName: Mutation
      FieldName: finishEvent
      DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name
  
  TriggereFinishEventResolver:
    Type: AWS::AppSync::Resolver
    Properties:
      ApiId: !Ref AppSyncApiId
      TypeName: Mutation
      FieldName: triggerFinishEvent
      DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name

Outputs:
  QueueName:
    Description: SNS queue name
    Value: !GetAtt SQSQueue.QueueName

  QueueARN:
    Description: SQS queue ARN
    Value: !GetAtt SQSQueue.Arn

  QueueURL:
    Description: SQS queue URL
    Value: !Ref SQSQueue
</code>
<code filename="livemarket/receiver/app.py">
from os import getenv
import json
import boto3
from gql_utils import get_client
from mutations import update_event_odds, finish_event, lock_bets_for_event
from gql import gql

from aws_lambda_powertools import Logger, Tracer
from aws_lambda_powertools.utilities.typing import LambdaContext
from aws_lambda_powertools.utilities.batch import BatchProcessor, EventType
from aws_lambda_powertools.utilities.data_classes.sqs_event import SQSRecord

processor = BatchProcessor(event_type=EventType.SQS)
tracer = Tracer()
logger = Logger()

appsync_url = getenv("APPSYNC_URL")
region = getenv("REGION")
event_bus_name = getenv('EVENT_BUS')
gql_client = get_client(region, appsync_url)
session = boto3.Session()
events = session.client('events')
sqsqueue = session.client('sqs')
queue_url = getenv('QUEUE')


@tracer.capture_method
def handle_updated_odds(item: dict) -> dict:
    update_info = {
        'eventId': item['detail']['eventId'],
        'homeOdds': item['detail']['homeOdds'],
        'awayOdds': item['detail']['awayOdds'],
        'drawOdds': item['detail']['drawOdds']
    }
    gql_input = {
        'input': update_info
    }
    response = gql_client.execute(gql(update_event_odds), variable_values=gql_input)[
        'updateEventOdds']

    if response['__typename'] == 'Event':
        logger.info("Odds updated")
        return form_event('com.livemarket', 'UpdatedOdds', update_info)
    elif 'Error' in response['__typename']:
        logger.exception("Failed to update odds")
        raise ValueError(
            f"updateEventOdds failed: {response['message']}")

@tracer.capture_method
def handle_event_finished(item: dict) -> dict:
    update_info = {
        'eventId': item['detail']['eventId'],
        'eventStatus': 'finished',
        'outcome': item['detail']['outcome']
    }
    gql_input = {
        'input': update_info
    }
    response = gql_client.execute(gql(finish_event), variable_values=gql_input)[
        'finishEvent']
    
    if response['__typename'] == 'Event':
        logger.info("Event closed")
        return form_event('com.livemarket', 'EventClosed', update_info)
    elif 'Error' in response['__typename']:
        logger.exception("Failed to update odds")
        raise ValueError(
            f"finish_event failed: {response['message']}")


def form_event(source, detailType, detail):
    return {
        'Source': source,
        'DetailType': detailType,
        'Detail': json.dumps(detail),
        'EventBusName': event_bus_name
    }

@tracer.capture_method
def record_handler(record: SQSRecord):
    # This function processes a record from SQS
    # Optionally return a dict which will be raised as a new event
    payload = record.body
    if payload:
        item = json.loads(payload)
        if item['source'] == 'com.trading':
            if item['detail-type'] == 'UpdatedOdds':
                return handle_updated_odds(item)
        if item['source'] == 'com.thirdparty':
            if item['detail-type'] == 'EventClosed':
                return handle_event_finished(item)
    logger.warning({"message": "Unknown record type", "record": item})
    return None


@logger.inject_lambda_context(log_event=True)
@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> dict:
    batch = event["Records"]
    with processor(records=batch, handler=record_handler):
        processed_messages = processor.process()
        logger.info(processed_messages)

    output_events = [x[1]
                     for x in processed_messages if x[0] == "success" and x[1] is not None]
    if output_events:
        events.put_events(Entries=output_events)

    return processor.response()
</code>
<code filename="livemarket/receiver/mutations.py">
update_event_odds = """
mutation MyMutation ($input: UpdateEventOddsInput!) {
  updateEventOdds(input: $input) {
    ... on Event {
      __typename
      start
      homeOdds
      awayOdds
      drawOdds
      home
      eventId
      end
      away,
      updatedAt
    }
    ... on Error {
      __typename
      message
    }
  }
}
"""

finish_event = """
mutation FinishEvent ($input: FinishEventInput!) {
  finishEvent(input: $input) {
    ... on Event {
      __typename
      start
      homeOdds
      awayOdds
      drawOdds
      home
      eventId
      end
      away,
      updatedAt
    }
    ... on Error {
      __typename
      message
    }
  }
}
"""

lock_bets_for_event = """
mutation MyMutation ($input: LockBetsForEventInput!){
  lockBetsForEvent (input: $input){
    ... on BetList {
      __typename
      nextToken
      items {
        amount
        userId
        betId
        odds
        outcome
        event{
          eventId
        }
      }
    }
    ... on UnknownError {
      __typename
      message
    }
    ... on InputError {
      __typename
      message
    }
    ... on NotFoundError {
      __typename
      message
    }
    ... on InsufficientFundsError {
      __typename
      message
    }
  }
}
"""
</code>
<code filename="livemarket/resolvers/app.py">
import time
from datetime import datetime
from decimal import Decimal
from os import getenv
import json
import boto3

from botocore.exceptions import ClientError

from aws_lambda_powertools.utilities.data_classes import AppSyncResolverEvent
from aws_lambda_powertools import Logger, Tracer
from aws_lambda_powertools.event_handler import AppSyncResolver
from aws_lambda_powertools.logging import correlation_paths
from aws_lambda_powertools.utilities.typing import LambdaContext
from aws_lambda_powertools.utilities.data_classes.appsync import scalar_types_utils

tracer = Tracer()
logger = Logger()
app = AppSyncResolver()

table_name = getenv('DB_TABLE')
history_table_name = getenv('DB_HISTORY_TABLE')
history_retention_seconds = int(getenv('DB_HISTORY_RETENTION'))
session = boto3.Session()
dynamodb = session.resource('dynamodb')
table = dynamodb.Table(table_name)
history_table = dynamodb.Table(history_table_name)
event_bus_name = getenv('EVENT_BUS')
events = session.client('events')


@app.resolver(type_name="Query", field_name="getEvents")
@tracer.capture_method
def get_events(startKey: str = "") -> dict:
    try:
        args = {}
        if startKey:
            args['ExclusiveStartKey'] = {'eventId': startKey}

        response = table.scan(**args)
        result = {
            'items': response.get('Items', [])
        }
        if response.get('LastEvaluatedKey'):
            result['nextToken'] = response['LastEvaluatedKey']['eventId']

        return event_list_response(result)

    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occured.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occured.')


@app.resolver(type_name="Query", field_name="getEvent")
@tracer.capture_method
def get_event(eventId: str, timestamp: float = None) -> dict:
    try:
        current_event = table.get_item(Key={'eventId': eventId})['Item']

        if timestamp is None:
            return event_response(current_event)

        current_event_ts = datetime.fromisoformat(
            current_event['updatedAt'][0:-1])
        requested_ts = datetime.fromtimestamp(timestamp)

        if current_event_ts < requested_ts:
            return event_response(current_event)

        # get the first entry from history that is older than the request
        matched_events = history_table.query(
            KeyConditionExpression='eventId = :e AND #t < :t',
            ExpressionAttributeValues={
                ':e': eventId,
                ':t': Decimal(requested_ts.timestamp())
            },
            ExpressionAttributeNames={
                '#t': 'timestamp'
            },
            Limit=1,
            ScanIndexForward=False
        )['Items']

        # We won't have matched events if the timestamp is further back than our history retention
        if not matched_events:
            return events_error('InputError', 'The history for this event is not queryable for the requested timestamp')

        return event_response(matched_events[0])
    except dynamodb.meta.client.exceptions.ResourceNotFoundException as e:
        return events_error('InputError', 'The event does not exist')
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occured.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occured.')


@app.resolver(type_name="Mutation", field_name="updateEventOdds")
@tracer.capture_method
def update_event_odds(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="set homeOdds=:h, awayOdds=:a, drawOdds=:d, updatedAt=:u",
            ConditionExpression="attribute_exists(eventId)",
            ExpressionAttributeValues={
                ':h': input['homeOdds'],
                ':a': input['awayOdds'],
                ':d': input['drawOdds'],
                ':u': now
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log to persist for the configured time
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except dynamodb.meta.client.exceptions.ConditionalCheckFailedException as e:
        return events_error('InputError', 'The event does not exist')
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occured.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occured.')


@app.resolver(type_name="Mutation", field_name="finishEvent")
@tracer.capture_method
def finish_event(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="set eventStatus=:d, updatedAt=:u, outcome=:o",
            ConditionExpression="attribute_exists(eventId)",
            ExpressionAttributeValues={
                ':d': input['eventStatus'],
                ':u': now,
                ':o': input['outcome']
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log to persist for the configured time
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except dynamodb.meta.client.exceptions.ConditionalCheckFailedException as e:
        return events_error('InputError', 'The event does not exist')
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occured.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occured.')


@app.resolver(type_name="Mutation", field_name="triggerFinishEvent")
@tracer.capture_method
def trigger_finish_event(input: dict) -> dict:
    try:
        #effectively just raising event back to event bridge
        current_event = get_event(input['eventId'])
        current_event["outcome"] = input["outcome"]
        send_event(current_event)
        print(current_event)
        return event_response(current_event)
    except dynamodb.meta.client.exceptions.ConditionalCheckFailedException as e:
        return events_error('InputError', 'The event does not exist')
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occured.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occured.')

def form_event(userResponse):
    return {
        'Source': 'com.thirdparty',
        'DetailType': 'EventClosed',
        'Detail': json.dumps(userResponse),
        'EventBusName': event_bus_name
    }

def send_event(userResponse):
    data = form_event(userResponse)
    response = events.put_events(Entries=[data])
    return response

def events_error(errorType: str, error_msg: str) -> dict:
    return {'__typename': errorType, 'message': error_msg}


def event_response(data: dict) -> dict:
    return {**{'__typename': 'Event'}, **data}


def event_list_response(data: dict) -> dict:
    return {**{'__typename': 'EventList'}, **data}


@logger.inject_lambda_context(correlation_id_path=correlation_paths.APPSYNC_RESOLVER, log_event=True)
@tracer.capture_lambda_handler
def lambda_handler(event: dict, context: LambdaContext) -> dict:
    return app.resolve(event, context)
</code>
<code filename="livemarket/seed/app.py">
from os import getenv
import boto3
import json

from crhelper import CfnResource

from aws_lambda_powertools import Logger
from aws_lambda_powertools.utilities.data_classes.appsync import scalar_types_utils

logger = Logger()

helper = CfnResource(json_logging=False, log_level='DEBUG',
                     boto_level='CRITICAL')

try:
    # Init clients and env vars here
    table_name = getenv('DB_TABLE')
    session = boto3.Session()
    dynamodb = session.resource('dynamodb')
    table = dynamodb.Table(table_name)
except Exception as e:
    helper.init_failure(e)


@helper.create
def create(event, context):
    with open('data.json', 'r') as f:
        events = json.load(f)

    logger.info(events)
    now = scalar_types_utils.aws_datetime()
    with table.batch_writer() as batch:
        for event_item in events:
            event_item['updatedAt'] = now
            event_item['eventStatus'] = 'running'
            batch.put_item(Item=event_item)

    logger.info('Event seed complete')

    return True



def lambda_handler(event, context):
    # This function is triggered by a CloudFormation custom resource.
    # It seeds a dynamodb table with some event data
    logger.info(event)
    helper(event, context)
</code>
<code filename="livemarket/seed/data.json">
[
  {
    "away": "Team 1",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "e46436a8-a916-4143-a05c-99d120eabfdb",
    "home": "Team 2",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 3",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "9a3d7a1f-4cf8-4db8-a13d-421ee9c35703",
    "home": "Team 4",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 5",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "0f66c58b-81eb-42c8-a058-62e54bba6493",
    "home": "Team 6",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 7",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "a613af9f-c76d-4384-ac43-96fcae0db562",
    "home": "Team 8",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 9",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "53837eee-4ba4-49f2-87be-76969b8ee68d",
    "home": "Team 10",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 11",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "ec1fec4d-2cdb-4c54-bb43-a7f89f73107d",
    "home": "Team 12",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 13",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "250a3a85-324f-4f4b-ae8d-f0419e4a20a6",
    "home": "Team 14",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 15",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "a0ed26b1-626e-4e30-8111-cc2b8e0293d7",
    "home": "Team 16",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 17",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "8badd072-b6e2-41fe-9c55-6d719b4af546",
    "home": "Team 18",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  },
  {
    "away": "Team 19",
    "awayOdds": "N/A",
    "drawOdds": "N/A",
    "end": "2024-01-01T16:45:00Z",
    "eventId": "ceac8915-fa87-4e08-93a7-e17c9a509fae",
    "home": "Team 20",
    "homeOdds": "N/A",
    "start": "2024-01-01T15:00:00Z"
  }
]
</code>

<code filename="livemarket/seed/requirements.txt">
crhelper==2.0.11
</code>

Sure, let's go through the steps to implement the "Suspend" and "Close" functionality for the Live Market service.

Step 1: Update the GraphQL schema
We need to update the GraphQL schema to include the "marketstatus" field for the Event type. Add the following code to the `schema.graphql` file:

```graphql
type Event @aws_cognito_user_pools @aws_iam {
  eventId: ID!
  homeOdds: String!
  awayOdds: String!
  drawOdds: String!
  home: String!
  away: String!
  start: AWSDateTime!
  end: AWSDateTime!
  updatedAt: AWSDateTime!
  eventStatus: EventStatus!
  outcome: String
  marketstatus: [MarketStatus]
}

type MarketStatus {
  name: String!
  status: String!
}
```

Step 2: Update the DynamoDB table
We need to update the DynamoDB table to store the "marketstatus" field. We can do this by modifying the `LiveMarketDataStore` resource in the `livemarket-service.yaml` file:

```yaml
LiveMarketDataStore:
  Type: AWS::DynamoDB::Table
  Properties:
    PointInTimeRecoverySpecification:
      PointInTimeRecoveryEnabled: true
    SSESpecification:
      SSEEnabled: true
    AttributeDefinitions:
      - AttributeName: eventId
        AttributeType: S
      - AttributeName: marketstatus.name
        AttributeType: S
    KeySchema:
      - AttributeName: eventId
        KeyType: HASH
    GlobalSecondaryIndexes:
      - IndexName: MarketStatusIndex
        KeySchema:
          - AttributeName: eventId
            KeyType: HASH
          - AttributeName: marketstatus.name
            KeyType: RANGE
        Projection:
          ProjectionType: ALL
    BillingMode: PAY_PER_REQUEST
```

This change adds a global secondary index to the DynamoDB table, which will allow us to query and update the "marketstatus" field efficiently.

Step 3: Update the backend code
We need to update the backend code to handle the "suspend" and "close" mutations. In the `livemarket/resolvers/app.py` file, add the following functions:

```python
@app.resolver(type_name="Mutation", field_name="suspendMarket")
@tracer.capture_method
def suspend_market(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="SET marketstatus = list_append(if_not_exists(marketstatus, :empty_list), :status)",
            ExpressionAttributeValues={
                ':empty_list': [],
                ':status': [{'name': input['market'], 'status': 'Suspended'}]
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')

@app.resolver(type_name="Mutation", field_name="closeMarket")
@tracer.capture_method
def close_market(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="SET marketstatus = list_append(if_not_exists(marketstatus, :empty_list), :status)",
            ExpressionAttributeValues={
                ':empty_list': [],
                ':status': [{'name': input['market'], 'status': 'Closed'}]
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
```

These functions handle the "suspendMarket" and "closeMarket" mutations, respectively. They update the "marketstatus" field in the DynamoDB table and write the current state to the history log.

Step 4: Update the frontend code
We need to update the frontend code to call the new "suspendMarket" and "closeMarket" mutations. In the `EventOdds.jsx` file, update the `renderOdds` function:

```jsx
const renderOdds = (params) => {
  const [suspendStatus, setSuspendStatus] = useState(false);

  const handleSuspend = () => {
    suspendMarket({ event: params.row.eventId, market: params.field });
    setSuspendStatus(!suspendStatus);
  };

  const handleClose = () => {
    closeMarket({ event: params.row.eventId, market: params.field });
  };

  return (
    <ButtonGroup>
      <Button
        variant="outlined"
        size="small"
        onClick={handleSuspend}
      >
        {suspendStatus ? 'Unsuspend' : 'Suspend'}
      </Button>
      <Button
        variant="outlined"
        size="small"
        color="error"
        onClick={handleClose}
      >
        Close
      </Button>
    </ButtonGroup>
  );
};
```

This code adds two new functions, `handleSuspend` and `handleClose`, which call the `suspendMarket` and `closeMarket` mutations, respectively. The `suspendStatus` state variable is used to toggle the button text between "Suspend" and "Unsuspend".

You also need to add the `suspendMarket` and `closeMarket` functions to the `EventOdds.jsx` file:

```jsx
const suspendMarket = async ({ event, market }) => {
  try {
    const input = { eventId: event, market };
    const response = await API.graphql(graphqlOperation(suspendMarketMutation, { input }));
    console.log(`Market '${market}' (${event}) suspended`);
  } catch (error) {
    console.error(`Error suspending market '${market}' (${event}):`, error);
  }
};

const closeMarket = async ({ event, market }) => {
  try {
    const input = { eventId: event, market };
    const response = await API.graphql(graphqlOperation(closeMarketMutation, { input }));
    console.log(`Market '${market}' (${event}) closed`);
  } catch (error) {
    console.error(`Error closing market '${market}' (${event}):`, error);
  }
};
```

These functions call the new GraphQL mutations using the Amplify API.

Finally, you need to add the GraphQL mutation definitions to the `graphql/mutations.js` file:

```js
export const suspendMarketMutation = /* GraphQL */ `
  mutation SuspendMarket($input: SuspendMarketInput!) {
    suspendMarket(input: $input) {
      ... on Event {
        eventId
        marketstatus {
          name
          status
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const closeMarketMutation = /* GraphQL */ `
  mutation CloseMarket($input: CloseMarketInput!) {
    closeMarket(input: $input) {
      ... on Event {
        eventId
        marketstatus {
          name
          status
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
```

And add the corresponding input types to the `schema.graphql` file:

```graphql
input SuspendMarketInput {
  eventId: ID!
  market: String!
}

input CloseMarketInput {
  eventId: ID!
  market: String!
}
```

Step 5: Deploy the changes
After making all the necessary changes, you need to deploy the updated CloudFormation stack and the frontend application.

That's it! With these changes, you should now be able to suspend and close markets using the buttons on the frontend. When a market is suspended, the button text will change to "Unsuspend", and clicking it again will unsuspend the market. The "Close" button will permanently close the market.

After making the changes when i run the application, frontend console renders following error: "Validation error of type FieldUndefined: Field 'suspendMarket' in type 'Mutation' is undefined @ 'suspendMarket'". How it can be fixed?
The error "Validation error of type FieldUndefined: Field 'suspendMarket' in type 'Mutation' is undefined @ 'suspendMarket'" indicates that the `suspendMarket` field is not defined in the GraphQL schema for the `Mutation` type.

To fix this issue, you need to add the `suspendMarket` and `closeMarket` fields to the `Mutation` type in the `schema.graphql` file.

```graphql
type Mutation {
  # ... existing mutations

  suspendMarket(input: SuspendMarketInput!): EventResult
  closeMarket(input: CloseMarketInput!): EventResult
}
```

And you need to add the corresponding resolvers for these mutations in the `livemarket/resolvers/app.py` file. You can add the following lines at the end of the file:

```python
app.resolver(type_name="Mutation", field_name="suspendMarket")(suspend_market)
app.resolver(type_name="Mutation", field_name="closeMarket")(close_market)
```

This will register the `suspend_market` and `close_market` functions as resolvers for the `suspendMarket` and `closeMarket` mutations, respectively.

Additionally, you need to add the `SuspendMarketInput` and `CloseMarketInput` input types to the `schema.graphql` file:

```graphql
input SuspendMarketInput {
  eventId: ID!
  market: String!
}

input CloseMarketInput {
  eventId: ID!
  market: String!
}
```

After making these changes, the error should be resolved, and you should be able to use the `suspendMarket` and `closeMarket` mutations from the frontend.

Seems like change to mutations.py is missing. Provide me with required changes to that file
You're correct, we also need to update the `mutations.py` file in the `livemarket/receiver/` directory to include the new `suspendMarket` and `closeMarket` mutations. Here's how you can update the `mutations.py` file:

```python
suspendMarketMutation = """
mutation SuspendMarket($input: SuspendMarketInput!) {
  suspendMarket(input: $input) {
    ... on Event {
      __typename
      eventId
      marketstatus {
        name
        status
      }
    }
    ... on Error {
      __typename
      message
    }
  }
}
"""

closeMarketMutation = """
mutation CloseMarket($input: CloseMarketInput!) {
  closeMarket(input: $input) {
    ... on Event {
      __typename
      eventId
      marketstatus {
        name
        status
      }
    }
    ... on Error {
      __typename
      message
    }
  }
}
"""
```

With these changes, the `mutations.py` file should now have the necessary GraphQL mutation definitions for `suspendMarket` and `closeMarket`.

You'll also need to import these new mutations in the `livemarket/receiver/app.py` file, so add the following lines at the top of the file:

```python
from mutations import suspendMarketMutation, closeMarketMutation
```

After making these changes, you should be able to use the `suspendMarket` and `closeMarket` mutations in your Lambda functions.

Also there is an update to livemarket-service.yaml missing. This update should create resolver connection between appsync and lambda function. Provide it to me.
You're right, we also need to update the `livemarket-service.yaml` file to create the resolvers for the `suspendMarket` and `closeMarket` mutations. Here's how you can update the file:

Add the following resources to the `livemarket-service.yaml` file:

```yaml
SuspendMarketResolver:
  Type: AWS::AppSync::Resolver
  Properties:
    ApiId: !Ref AppSyncApiId
    TypeName: Mutation
    FieldName: suspendMarket
    DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name

CloseMarketResolver:
  Type: AWS::AppSync::Resolver
  Properties:
    ApiId: !Ref AppSyncApiId
    TypeName: Mutation
    FieldName: closeMarket
    DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name
```

These resources create the resolvers for the `suspendMarket` and `closeMarket` mutations and associate them with the `LiveMarketLambdaDataSource` data source, which is connected to the `LiveMarketResolverFunction` Lambda function.

After adding these resources, the `livemarket-service.yaml` file should be able to map the `suspendMarket` and `closeMarket` mutations to the appropriate Lambda functions, allowing you to execute the mutations through the AppSync API.

Make sure to deploy the updated CloudFormation stack after making these changes to the `livemarket-service.yaml` file.

Now it works. However when i refresh the page, the button on frontend returns to "suspend" text even though on backend the corresponding market is suspended. So the button should render "unsuspend" if market is suspended on a backend even after page reload. I need you to fix that.
To fix the issue where the button text reverts to "Suspend" after a page refresh, even when the market is suspended on the backend, we need to update the frontend code to fetch the current market status from the backend and update the button text accordingly.

Here's how you can update the `EventOdds.jsx` file:

1. First, import the necessary GraphQL query and mutation from the `graphql/queries.js` and `graphql/mutations.js` files:

```jsx
import { getEvent } from './graphql/queries';
import { suspendMarketMutation, closeMarketMutation } from './graphql/mutations';
```

2. In the `renderOdds` function, create a new state variable to store the market status for the current event:

```jsx
const renderOdds = (params) => {
  const [marketStatus, setMarketStatus] = useState('');

  // Fetch the current market status from the backend
  useEffect(() => {
    const fetchMarketStatus = async () => {
      try {
        const eventData = await API.graphql(graphqlOperation(getEvent, { eventId: params.row.eventId }));
        const currentMarketStatus = eventData.data.getEvent.marketstatus.find(
          (market) => market.name === params.field
        );
        setMarketStatus(currentMarketStatus ? currentMarketStatus.status : '');
      } catch (error) {
        console.error('Error fetching market status:', error);
      }
    };

    fetchMarketStatus();
  }, [params.row.eventId, params.field]);

  // ... (rest of the code remains the same)
};
```

This code fetches the current market status from the backend using the `getEvent` query and updates the `marketStatus` state variable accordingly.

3. Update the `handleSuspend` function to use the `marketStatus` state variable to determine the button text:

```jsx
const handleSuspend = () => {
  suspendMarket({ event: params.row.eventId, market: params.field });
  setMarketStatus((prevStatus) => (prevStatus === 'Suspended' ? 'Active' : 'Suspended'));
};
```

4. Update the button text to use the `marketStatus` state variable:

```jsx
<Button
  variant="outlined"
  size="small"
  onClick={handleSuspend}
>
  {marketStatus === 'Suspended' ? 'Unsuspend' : 'Suspend'}
</Button>
```

With these changes, the frontend will fetch the current market status from the backend and update the button text accordingly. When the page is refreshed, the correct button text ("Unsuspend" or "Suspend") will be displayed based on the market status in the backend.

Please note that you may need to update the `suspendMarket` and `closeMarket` mutations in the `graphql/mutations.js` file to include the `marketstatus` field in the response, so that the frontend can update the button text correctly after executing the mutations.

The event data is coming initially via "useEvents" hook when page loads. So to make it easier, just expand events data with market status in graphql schemas and use that data to render proper button text. Provide me with required changes.

To expand the events data with market status and use it to render the proper button text, we need to make changes in multiple files. Here are the required changes:

1. Update the `schema.graphql` file to include the `marketstatus` field in the `Event` type:

```graphql
type Event @aws_cognito_user_pools @aws_iam {
  eventId: ID!
  homeOdds: String!
  awayOdds: String!
  drawOdds: String!
  home: String!
  away: String!
  start: AWSDateTime!
  end: AWSDateTime!
  updatedAt: AWSDateTime!
  eventStatus: EventStatus!
  outcome: String
  marketstatus: [MarketStatus]
}
```

2. Update the `livemarket/resolvers/app.py` file to include the `marketstatus` field in the response for the `getEvents` resolver:

```python
@app.resolver(type_name="Query", field_name="getEvents")
@tracer.capture_method
def get_events(startKey: str = "") -> dict:
    try:
        args = {}
        if startKey:
            args['ExclusiveStartKey'] = {'eventId': startKey}

        response = table.scan(**args)
        result = {
            'items': response.get('Items', [])
        }
        if response.get('LastEvaluatedKey'):
            result['nextToken'] = response['LastEvaluatedKey']['eventId']

        return event_list_response(result)

    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')

def event_list_response(data: dict) -> dict:
    items = data.get('items', [])
    for item in items:
        item['marketstatus'] = item.get('marketstatus', [])
    return {**{'__typename': 'EventList'}, **data}
```

This change ensures that the `marketstatus` field is included in the response for each event.

3. Update the `EventOdds.jsx` file to use the `marketstatus` data from the events:

```jsx
const renderOdds = (params) => {
  const marketStatus = params.row.marketstatus.find((market) => market.name === params.field)?.status || '';

  const handleSuspend = () => {
    suspendMarket({ event: params.row.eventId, market: params.field });
  };

  const handleClose = () => {
    closeMarket({ event: params.row.eventId, market: params.field });
  };

  return (
    <ButtonGroup>
      <Button
        variant="outlined"
        size="small"
        onClick={handleSuspend}
      >
        {marketStatus === 'Suspended' ? 'Unsuspend' : 'Suspend'}
      </Button>
      <Button
        variant="outlined"
        size="small"
        color="error"
        onClick={handleClose}
      >
        Close
      </Button>
    </ButtonGroup>
  );
};
```

In this updated code, we retrieve the `marketStatus` directly from the event data (`params.row.marketstatus`). The `marketStatus` variable will contain the current status of the market, which is then used to render the correct button text.

With these changes, the frontend should now display the correct button text ("Suspend" or "Unsuspend") based on the market status fetched from the backend when the page loads or after a refresh.

Now when obtaining items from backend, the console renders an error: "Cannot return null for non-nullable type: 'null' within parent 'Event' (/getEvents/items[1]/marketstatus)". It happens because most items do not have "marketstatus" item and schema does not allow null in that field. How to fix it?

The error "Cannot return null for non-nullable type: 'null' within parent 'Event' (/getEvents/items[1]/marketstatus)" occurs because the GraphQL schema requires the `marketstatus` field to be present for every `Event` object, but some of the events in the backend data don't have the `marketstatus` field.

To fix this issue, we can make the `marketstatus` field nullable in the GraphQL schema by adding the `@aws_iam @aws_cognito_user_pools` directive to the `MarketStatus` type. This way, if the `marketstatus` field is not present in the backend data, it will be set to `null` instead of causing an error.

Update the `schema.graphql` file as follows:

```graphql
type Event @aws_cognito_user_pools @aws_iam {
  eventId: ID!
  homeOdds: String!
  awayOdds: String!
  drawOdds: String!
  home: String!
  away: String!
  start: AWSDateTime!
  end: AWSDateTime!
  updatedAt: AWSDateTime!
  eventStatus: EventStatus!
  outcome: String
  marketstatus: [MarketStatus] @aws_iam @aws_cognito_user_pools
}

type MarketStatus @aws_iam @aws_cognito_user_pools {
  name: String!
  status: String!
}
```

By adding the `@aws_iam @aws_cognito_user_pools` directive to the `MarketStatus` type, we're telling AppSync to return `null` if the `marketstatus` field is missing from the backend data, instead of throwing an error.

Additionally, we need to update the `livemarket/resolvers/app.py` file to handle the case when `marketstatus` is `null`. We can update the `event_list_response` function as follows:

```python
def event_list_response(data: dict) -> dict:
    items = data.get('items', [])
    for item in items:
        item['marketstatus'] = item.get('marketstatus', [])
    return {**{'__typename': 'EventList'}, **data}
```

This change ensures that if the `marketstatus` field is missing in the backend data, it will be set to an empty list (`[]`) instead of `null`.

After making these changes, the error should be resolved, and the frontend should be able to handle events that don't have the `marketstatus` field.

Now frontend throws an error "Cannot read properties of null (reading 'find')". How to fix it?
The error "Cannot read properties of null (reading 'find')" occurs because the `renderOdds` function in the `EventOdds.jsx` file is trying to call the `find` method on `params.row.marketstatus`, but `params.row.marketstatus` is `null`. This can happen if the `marketstatus` field is not present or is `null` for a particular event in the backend data.

To fix this issue, we need to check if `params.row.marketstatus` is not `null` before calling the `find` method. We can do this by adding a conditional check in the `renderOdds` function.

Update the `renderOdds` function in the `EventOdds.jsx` file as follows:

```jsx
const renderOdds = (params) => {
  let marketStatus = '';

  if (params.row.marketstatus) {
    const currentMarket = params.row.marketstatus.find((market) => market.name === params.field);
    marketStatus = currentMarket ? currentMarket.status : '';
  }

  const handleSuspend = () => {
    suspendMarket({ event: params.row.eventId, market: params.field });
  };

  const handleClose = () => {
    closeMarket({ event: params.row.eventId, market: params.field });
  };

  return (
    <ButtonGroup>
      <Button
        variant="outlined"
        size="small"
        onClick={handleSuspend}
      >
        {marketStatus === 'Suspended' ? 'Unsuspend' : 'Suspend'}
      </Button>
      <Button
        variant="outlined"
        size="small"
        color="error"
        onClick={handleClose}
      >
        Close
      </Button>
    </ButtonGroup>
  );
};
```

In this updated code, we first check if `params.row.marketstatus` is not `null`. If it's not `null`, we proceed to find the current market status using the `find` method. If `params.row.marketstatus` is `null`, the `marketStatus` variable will be an empty string.

Now i need a change that unsuspends the market if it is in "suspended" status. This should happen when i click on a button with "unsuspend" text on it. After backend updates data in dynamodb, it should change the button text to "suspend".

This way, even if the `marketstatus` field is missing or `null` for a particular event, the `renderOdds` function will not throw an error and will display the "Suspend" button by default.

After making this change, the error should be resolved, and the frontend should be able to handle events with or without the `marketstatus` field correctly.
To implement the functionality to unsuspend a market when the "Unsuspend" button is clicked, we need to make changes on both the frontend and backend.

1. **Backend Changes**:

In the `livemarket/resolvers/app.py` file, add a new resolver function for the `unsuspendMarket` mutation. This function will update the `marketstatus` field in the DynamoDB table to set the status to "Active" for the specified market.

```python
@app.resolver(type_name="Mutation", field_name="unsuspendMarket")
@tracer.capture_method
def unsuspend_market(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="SET marketstatus = list_append(if_not_exists(marketstatus, :empty_list), :status)",
            ExpressionAttributeValues={
                ':empty_list': [],
                ':status': [{'name': input['market'], 'status': 'Active'}]
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
```

Also, register the `unsuspend_market` function as a resolver for the `unsuspendMarket` mutation by adding the following line at the end of the `livemarket/resolvers/app.py` file:

```python
app.resolver(type_name="Mutation", field_name="unsuspendMarket")(unsuspend_market)
```

2. **Frontend Changes**:

In the `EventOdds.jsx` file, update the `handleSuspend` function to call the `suspendMarket` or `unsuspendMarket` mutation based on the current market status.

```jsx
const handleSuspend = async () => {
  try {
    const input = { eventId: params.row.eventId, market: params.field };
    if (marketStatus === 'Suspended') {
      const response = await API.graphql(graphqlOperation(unsuspendMarketMutation, { input }));
      console.log(`Market '${params.field}' (${params.row.eventId}) unsuspended`);
    } else {
      const response = await API.graphql(graphqlOperation(suspendMarketMutation, { input }));
      console.log(`Market '${params.field}' (${params.row.eventId}) suspended`);
    }
    setMarketStatus((prevStatus) => (prevStatus === 'Suspended' ? 'Active' : 'Suspended'));
  } catch (error) {
    console.error(`Error updating market '${params.field}' (${params.row.eventId}):`, error);
  }
};
```

This updated `handleSuspend` function checks the current `marketStatus` and calls either the `suspendMarketMutation` or `unsuspendMarketMutation` accordingly. It also updates the `marketStatus` state variable to toggle the button text between "Suspend" and "Unsuspend".

3. **Update GraphQL Mutations**:

In the `graphql/mutations.js` file, add the definition for the `unsuspendMarketMutation`:

```js
export const unsuspendMarketMutation = /* GraphQL */ `
  mutation UnsuspendMarket($input: UnsuspendMarketInput!) {
    unsuspendMarket(input: $input) {
      ... on Event {
        eventId
        marketstatus {
          name
          status
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
```

And add the corresponding input type to the `schema.graphql` file:

```graphql
input UnsuspendMarketInput {
  eventId: ID!
  market: String!
}
```

4. **Update livemarket-service.yaml**:

In the `livemarket-service.yaml` file, add a new resolver for the `unsuspendMarket` mutation:

```yaml
UnsuspendMarketResolver:
  Type: AWS::AppSync::Resolver
  Properties:
    ApiId: !Ref AppSyncApiId
    TypeName: Mutation
    FieldName: unsuspendMarket
    DataSourceName: !GetAtt LiveMarketLambdaDataSource.Name
```

After making these changes, you should be able to unsuspend a market by clicking the "Unsuspend" button. The backend will update the `marketstatus` field in the DynamoDB table to set the status to "Active" for the specified market, and the frontend will update the button text to "Suspend".

Seems like you forgot some detail. I get an error "ReferenceError: unsuspendMarketMutation is not defined". How to fix it?
The error "ReferenceError: unsuspendMarketMutation is not defined" occurs because the `unsuspendMarketMutation` is not imported correctly in the `EventOdds.jsx` file.

To fix this issue, you need to import the `unsuspendMarketMutation` from the `graphql/mutations.js` file in the `EventOdds.jsx` file.

1. Open the `EventOdds.jsx` file.

2. At the top of the file, add the following import statement:

```jsx
import { suspendMarketMutation, closeMarketMutation, unsuspendMarketMutation } from './graphql/mutations';
```

Now, the `unsuspendMarketMutation` should be available for use in the `EventOdds.jsx` file, and the error should be resolved.

Please note that the path `./graphql/mutations` assumes that the `graphql/mutations.js` file is located in the same directory as the `EventOdds.jsx` file. If the file structure is different in your project, you'll need to adjust the import path accordingly.

After adding the import statement, the `handleSuspend` function should be able to use the `unsuspendMarketMutation` without any issues.

Backend code adds new record to dynamodb table every time the suspend or unsuspend action comes. I want it to update the market status if it is already present in marketstatus item.
To update the existing market status in the `marketstatus` field instead of adding a new record, we need to modify the `suspend_market` and `unsuspend_market` functions in the `livemarket/resolvers/app.py` file. Here's how you can update these functions:

1. Update the `suspend_market` function:

```python
@app.resolver(type_name="Mutation", field_name="suspendMarket")
@tracer.capture_method
def suspend_market(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="SET marketstatus = :status",
            ConditionExpression="attribute_exists(eventId)",
            ExpressionAttributeValues={
                ':status': [{'name': input['market'], 'status': 'Suspended'}]
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
```

2. Update the `unsuspend_market` function:

```python
@app.resolver(type_name="Mutation", field_name="unsuspendMarket")
@tracer.capture_method
def unsuspend_market(input: dict) -> dict:
    try:
        now = scalar_types_utils.aws_datetime()
        response = table.update_item(
            Key={'eventId': input['eventId']},
            UpdateExpression="SET marketstatus = :status",
            ConditionExpression="attribute_exists(eventId)",
            ExpressionAttributeValues={
                ':status': [{'name': input['market'], 'status': 'Active'}]
            },
            ReturnValues="ALL_NEW")
        current_event = response['Attributes']

        # Write the current state to the history log
        epoch = Decimal(time.time())
        history_entry = {**current_event, **
                         {'timestamp': epoch, 'expiry': epoch + history_retention_seconds}}
        history_table.put_item(Item=history_entry)

        return event_response(current_event)
    except ClientError as e:
        logger.exception({'ClientError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
    except Exception as e:
        logger.exception({'UnknownError': e})
        return events_error('UnknownError', 'An unknown error occurred.')
```

The main changes in these functions are:

- Instead of using the `list_append` update expression, we're using the `SET` update expression to replace the entire `marketstatus` field with the new value.
- We're setting the `marketstatus` field to a list containing a single dictionary with the `name` and `status` keys, which will replace the existing value.
- We've added a `ConditionExpression` to ensure that the update operation only occurs if the event exists in the table.

With these changes, when you suspend or unsuspend a market, the existing `marketstatus` field will be updated with the new status for that market, instead of adding a new record. If the `marketstatus` field doesn't exist for a particular event, it will be created with the new status.

Now i want button to change its text not based on state, but on response from backend that signals that suspend/unsuspend action was successfull. While frontend awaits for response, it should deactivate the button
To change the button text based on the response from the backend and deactivate the button while awaiting the response, we need to make the following changes:

1. Update the `renderOdds` function in the `EventOdds.jsx` file:

```jsx
const renderOdds = (params) => {
  const [isLoading, setIsLoading] = useState(false);
  const [marketStatus, setMarketStatus] = useState('');

  useEffect(() => {
    const fetchMarketStatus = async () => {
      try {
        const eventData = await API.graphql(graphqlOperation(getEvent, { eventId: params.row.eventId }));
        const currentMarket = eventData.data.getEvent.marketstatus.find(
          (market) => market.name === params.field
        );
        setMarketStatus(currentMarket ? currentMarket.status : '');
      } catch (error) {
        console.error('Error fetching market status:', error);
      }
    };

    fetchMarketStatus();
  }, [params.row.eventId, params.field]);

  const handleSuspend = async () => {
    setIsLoading(true);
    try {
      const input = { eventId: params.row.eventId, market: params.field };
      if (marketStatus === 'Suspended') {
        const response = await API.graphql(graphqlOperation(unsuspendMarketMutation, { input }));
        setMarketStatus(response.data.unsuspendMarket.marketstatus.find((market) => market.name === params.field).status);
        console.log(`Market '${params.field}' (${params.row.eventId}) unsuspended`);
      } else {
        const response = await API.graphql(graphqlOperation(suspendMarketMutation, { input }));
        setMarketStatus(response.data.suspendMarket.marketstatus.find((market) => market.name === params.field).status);
        console.log(`Market '${params.field}' (${params.row.eventId}) suspended`);
      }
    } catch (error) {
      console.error(`Error updating market '${params.field}' (${params.row.eventId}):`, error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () => {
    closeMarket({ event: params.row.eventId, market: params.field });
  };

  return (
    <ButtonGroup>
      <Button
        variant="outlined"
        size="small"
        onClick={handleSuspend}
        disabled={isLoading}
      >
        {marketStatus === 'Suspended' ? 'Unsuspend' : 'Suspend'}
      </Button>
      <Button
        variant="outlined"
        size="small"
        color="error"
        onClick={handleClose}
        disabled={isLoading}
      >
        Close
      </Button>
    </ButtonGroup>
  );
};
```

In this updated code:

- We added a new state variable `isLoading` to track if the suspend/unsuspend action is in progress.
- In the `handleSuspend` function:
  - We set `isLoading` to `true` before making the API call.
  - After the API call, we update the `marketStatus` based on the response from the backend.
  - We set `isLoading` to `false` in the `finally` block, ensuring that it's reset even if an error occurs.
- We added the `disabled` prop to the buttons and set it to the value of `isLoading`. This will disable the buttons while the suspend/unsuspend action is in progress.

2. Update the `suspendMarketMutation` and `unsuspendMarketMutation` in the `graphql/mutations.js` file to include the updated `marketstatus` field in the response:

```js
export const suspendMarketMutation = /* GraphQL */ `
  mutation SuspendMarket($input: SuspendMarketInput!) {
    suspendMarket(input: $input) {
      ... on Event {
        eventId
        marketstatus {
          name
          status
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;

export const unsuspendMarketMutation = /* GraphQL */ `
  mutation UnsuspendMarket($input: UnsuspendMarketInput!) {
    unsuspendMarket(input: $input) {
      ... on Event {
        eventId
        marketstatus {
          name
          status
        }
      }
      ... on Error {
        __typename
        message
      }
    }
  }
`;
```

With these changes, the button text will be updated based on the response from the backend, and the button will be disabled while the suspend/unsuspend action is in progress. If an error occurs, the button will be re-enabled, and the error will be logged to the console.