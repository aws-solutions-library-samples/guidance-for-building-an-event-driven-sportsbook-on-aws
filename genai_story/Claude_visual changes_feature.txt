You area web developer. I will provide you a code for a frontend component. This component renders bets that were placed and rendered after coming from backend. The bets are rendered in a grid. I want you to change the grid layout so that if bet outcome matches the event outcome, the row background for the bet would be colored in light green. Otherwise, the row background should be colored in light orange.

<code>
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: false,
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: false,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: false,
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: false,
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (

    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <DataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;

</code>


To change the row background color based on the condition you specified, we need to use the `getRowClassName` prop of the `DataGrid` component. This prop allows us to define a function that returns a class name for each row based on its data. Here's how you can modify the code:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getRowClassName = (params) => {
  const { outcome, event } = params.row;
  if (outcome === event.outcome) {
    return "win-row";
  } else {
    return "lose-row";
  }
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: false,
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: false,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: false,
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: false,
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <DataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
```

In this modified code, we define a new function called `getRowClassName` that takes the row data as a parameter. Inside this function, we compare the `outcome` value of the bet with the `event.outcome` value. If they match, we return the class name `"win-row"`, otherwise we return `"lose-row"`.

Then, we pass this `getRowClassName` function to the `getRowClassName` prop of the `DataGrid` component.

Next, you need to define the CSS styles for the `win-row` and `lose-row` classes in your CSS file or using inline styles. For example:

```css
.win-row {
  background-color: lightgreen;
}

.lose-row {
  background-color: lightorange;
}
```

With these changes, the rows with a winning bet will have a light green background, and the rows with a losing bet will have a light orange background.

Use standard mui styling functionality. I will provide you an example

<examplecode>
import * as React from 'react';
import Box from '@mui/material/Box';
import { DataGrid } from '@mui/x-data-grid';
import { useDemoData } from '@mui/x-data-grid-generator';
import { darken, lighten, styled } from '@mui/material/styles';

const getBackgroundColor = (color, mode) =>
  mode === 'dark' ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === 'dark' ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === 'dark' ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === 'dark' ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  '& .super-app-theme--Open': {
    backgroundColor: getBackgroundColor(theme.palette.info.main, theme.palette.mode),
    '&:hover': {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.info.main,
        theme.palette.mode,
      ),
    },
    '&.Mui-selected': {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.info.main,
        theme.palette.mode,
      ),
      '&:hover': {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.info.main,
          theme.palette.mode,
        ),
      },
    },
  },
  '& .super-app-theme--Filled': {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode,
    ),
    '&:hover': {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode,
      ),
    },
    '&.Mui-selected': {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode,
      ),
      '&:hover': {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode,
        ),
      },
    },
  },
  '& .super-app-theme--PartiallyFilled': {
    backgroundColor: getBackgroundColor(
      theme.palette.warning.main,
      theme.palette.mode,
    ),
    '&:hover': {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.warning.main,
        theme.palette.mode,
      ),
    },
    '&.Mui-selected': {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.warning.main,
        theme.palette.mode,
      ),
      '&:hover': {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.warning.main,
          theme.palette.mode,
        ),
      },
    },
  },
  '& .super-app-theme--Rejected': {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode,
    ),
    '&:hover': {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode,
      ),
    },
    '&.Mui-selected': {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode,
      ),
      '&:hover': {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode,
        ),
      },
    },
  },
}));

export default function StylingRowsGrid() {
  const { data } = useDemoData({
    dataSet: 'Commodity',
    rowLength: 100,
  });

  return (
    <Box sx={{ height: 400, width: '100%' }}>
      <StyledDataGrid
        {...data}
        getRowClassName={(params) => `super-app-theme--${params.row.status}`}
      />
    </Box>
  );
}
</examplecode>
Sure, we can use a similar approach to style the rows based on the bet outcome. Here's how you can modify the code:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  "& .win-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .lose-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode
        ),
      },
    },
  },
}));

const getRowClassName = (params) => {
  const { outcome, event } = params.row;
  if (outcome === event.outcome) {
    return "win-row";
  } else {
    return "lose-row";
  }
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    // ... (columns definition)
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <StyledDataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
```

In this modified code, we first import the `darken`, `lighten`, and `styled` functions from `@mui/material/styles`. We then define helper functions `getBackgroundColor`, `getHoverBackgroundColor`, `getSelectedBackgroundColor`, and `getSelectedHoverBackgroundColor` to calculate the appropriate background colors based on the theme's palette and mode.

Next, we create a styled component `StyledDataGrid` that extends the `DataGrid` component with custom styles. We define two CSS rules:

1. `& .win-row`: This rule applies styles to rows with the `win-row` class. It sets the background color, hover background color, and selected background color using the `success` color from the theme's palette.
2. `& .lose-row`: This rule applies styles to rows with the `lose-row` class. It sets the background color, hover background color, and selected background color using the `error` color from the theme's palette.

The `getRowClassName` function remains the same as before, returning either `"win-row"` or `"lose-row"` based on the bet outcome.

Finally, in the `BetHistory` component, we replace the `DataGrid` component with the `StyledDataGrid` component and pass the `getRowClassName` function as a prop.

With these changes, the rows with a winning bet will have a light green background (based on the `success` color from the theme's palette), and the rows with a losing bet will have a light orange background (based on the `error` color from the theme's palette). The hover and selected states will also be styled accordingly.

Now update the code so that grid has an additional column next to odds. This column should render "Your win" or "Your Loss" outcome. Column header should be "Outcome". Value for the column is a calculation of a bet amount and odds. bet amount is in bet.amount value and bet odds is in bet.odds. Odds are presented in fractional format. Ex. 1/2, 3/4, 5/2 etc. 
Sure, here's the updated code with the additional column for "Your win" or "Your Loss" outcome:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  "& .win-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .lose-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode
        ),
      },
    },
  },
}));

const getRowClassName = (params) => {
  const { outcome, event } = params.row;
  if (outcome === event.outcome) {
    return "win-row";
  } else {
    return "lose-row";
  }
};

const calculateOutcome = (amount, odds) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  return profitAmount > 0 ? `Your Win: $${profitAmount}` : `Your Loss: $${-profitAmount}`;
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: false,
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: false,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "result",
      headerName: "Outcome",
      sortable: false,
      valueGetter: (params) =>
        calculateOutcome(params.row.amount, params.row.odds),
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: false,
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: false,
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <StyledDataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
```

Here are the changes:

1. We added a new column definition for the "Outcome" column:

```js
{
  field: "result",
  headerName: "Outcome",
  sortable: false,
  valueGetter: (params) =>
    calculateOutcome(params.row.amount, params.row.odds),
},
```

2. We defined a new function `calculateOutcome` that takes the bet amount (`amount`) and odds (`odds`) as parameters. It calculates the win/loss amount based on the odds and returns a string in the format "Your Win: $X" or "Your Loss: $X".

```js
const calculateOutcome = (amount, odds) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  return profitAmount > 0 ? `Your Win: $${profitAmount}` : `Your Loss: $${-profitAmount}`;
};
```

3. In the `valueGetter` function for the "Outcome" column, we call the `calculateOutcome` function with the `amount` and `odds` values from the row data.

With these changes, the grid will have an additional column next to the odds column, which will display either "Your Win: $X" or "Your Loss: $X" based on the bet amount and odds. The column header will be "Outcome".

Note: This code assumes that the `bets` data contains `amount` and `odds` properties for each bet. If the data structure is different, you may need to adjust the `calculateOutcome` function and the `valueGetter` accordingly.

Next update set:
1. Remove "Your win" and "Your loss" text and replace with "-" (minus sign) if player lost money
2. If bet outcome is different from event outcome it means player lost anyway, it is also is a loss. This needs to be updated.
3. Move this column directly next to "Your Odds" column

Sure, here's the updated code with the requested changes:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  "& .win-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .lose-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode
        ),
      },
    },
  },
}));

const getRowClassName = (params) => {
  const { outcome, event } = params.row;
  if (outcome === event.outcome) {
    return "win-row";
  } else {
    return "lose-row";
  }
};

const calculateOutcome = (amount, odds, outcome, eventOutcome) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  if (outcome !== eventOutcome) {
    return "-";
  } else if (profitAmount > 0) {
    return `$${profitAmount}`;
  } else {
    return "-";
  }
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: false,
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: false,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "result",
      headerName: "Outcome",
      sortable: false,
      valueGetter: (params) =>
        calculateOutcome(
          params.row.amount,
          params.row.odds,
          params.row.outcome,
          params.row.event.outcome
        ),
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: false,
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: false,
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <StyledDataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
```

Here are the changes:

1. The `calculateOutcome` function now takes an additional parameter `eventOutcome`. It checks if the `outcome` and `eventOutcome` are different, and if so, it returns a "-" (minus sign) to indicate a loss. If the `outcome` and `eventOutcome` match, it calculates the profit amount and returns `$${profitAmount}` if positive, or "-" if negative.

```js
const calculateOutcome = (amount, odds, outcome, eventOutcome) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  if (outcome !== eventOutcome) {
    return "-";
  } else if (profitAmount > 0) {
    return `$${profitAmount}`;
  } else {
    return "-";
  }
};
```

2. In the `valueGetter` function for the "Outcome" column, we pass the `outcome` and `event.outcome` values to the `calculateOutcome` function.

```js
{
  field: "result",
  headerName: "Outcome",
  sortable: false,
  valueGetter: (params) =>
    calculateOutcome(
      params.row.amount,
      params.row.odds,
      params.row.outcome,
      params.row.event.outcome
    ),
},
```

3. The "Outcome" column is now moved directly next to the "Your Odds" column in the `columns` array definition.

With these changes, the "Outcome" column will display:

- "-" (minus sign) if the player lost money, either because the bet outcome didn't match the event outcome or because the player's odds resulted in a loss.
- The profit amount in the format `$X` if the player won money.

The row background colors will still be applied based on the `getRowClassName` function, which compares the `outcome` and `event.outcome` values.

I have changed code a bit. I will provide an updated code. Now i need you to change the color of grid so that previous conditions stand, however, if event outcome and bet outcome matches, but player still lost money based on odds calculation, the color of the row should be yellow.

<code>
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  "& .win-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .lose-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode
        ),
      },
    },
  },
}));

const getRowClassName = (params) => {
  const { outcome, event } = params.row;
  if (outcome === event.outcome) {
    return "win-row";
  } else {
    return "lose-row";
  }
};

const calculateOutcome = (amount, odds, outcome, eventOutcome) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  //round up the profitAmount to 2 digits
  const roundedProfitAmount = Math.round(profitAmount * 100) / 100;
  if (outcome !== eventOutcome) {
    return "-"+`$${amount}`;
  } else if (roundedProfitAmount > 0) {
    return `$${roundedProfitAmount}`;
  } else {
    return `$${roundedProfitAmount}`;
  }
};

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: false,
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: false,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "result",
      headerName: "Outcome",
      sortable: false,
      valueGetter: (params) =>
        calculateOutcome(
          params.row.amount,
          params.row.odds,
          params.row.outcome,
          params.row.event.outcome
        ),
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: false,
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: false,
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: false,
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <StyledDataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }],
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
</code>
Sure, I can update the code to meet the new requirement. Here's the updated code:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

const dateOptions = {
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
};

const conditionFormat = {
  homeWin: "Home Win",
  awayWin: "Away Win",
  draw: "Draw",
};

const betStatusFormat = {
  placed: "Placed",
  resulted: "Resulted",
  settled: "Settled",
};

const getBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.7) : lighten(color, 0.7);

const getHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.6) : lighten(color, 0.6);

const getSelectedBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.5) : lighten(color, 0.5);

const getSelectedHoverBackgroundColor = (color, mode) =>
  mode === "dark" ? darken(color, 0.4) : lighten(color, 0.4);

const StyledDataGrid = styled(DataGrid)(({ theme }) => ({
  "& .win-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.success.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.success.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.success.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .lose-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.error.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.error.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.error.main,
          theme.palette.mode
        ),
      },
    },
  },
  "& .draw-row": {
    backgroundColor: getBackgroundColor(
      theme.palette.warning.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getHoverBackgroundColor(
        theme.palette.warning.main,
        theme.palette.mode
      ),
    },
    "&.Mui-selected": {
      backgroundColor: getSelectedBackgroundColor(
        theme.palette.warning.main,
        theme.palette.mode
      ),
      "&:hover": {
        backgroundColor: getSelectedHoverBackgroundColor(
          theme.palette.warning.main,
          theme.palette.mode
        ),
      },
    },
  },
}));

const getRowClassName = (params) => {
  const { outcome, event, amount, odds } = params.row;
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;

  if (outcome === event.outcome && profitAmount > 0) {
    return "win-row";
  } else if (outcome === event.outcome && profitAmount <= 0) {
    return "draw-row";
  } else {
    return "lose-row";
  }
};

const calculateOutcome = (amount, odds, outcome, eventOutcome) => {
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;
  //round up the profitAmount to 2 digits
  const roundedProfitAmount = Math.round(profitAmount * 100) / 100;
  if (outcome !== eventOutcome) {
    return "-" + `$${amount}`;
  } else {
    return `$${roundedProfitAmount}`;
  }
};

// ... (rest of the code remains the same)
```

Here are the changes:

1. We added a new CSS rule for the `draw-row` class in the `StyledDataGrid` component:

```js
"& .draw-row": {
  backgroundColor: getBackgroundColor(
    theme.palette.warning.main,
    theme.palette.mode
  ),
  "&:hover": {
    backgroundColor: getHoverBackgroundColor(
      theme.palette.warning.main,
      theme.palette.mode
    ),
  },
  "&.Mui-selected": {
    backgroundColor: getSelectedBackgroundColor(
      theme.palette.warning.main,
      theme.palette.mode
    ),
    "&:hover": {
      backgroundColor: getSelectedHoverBackgroundColor(
        theme.palette.warning.main,
        theme.palette.mode
      ),
    },
  },
},
```

This rule sets the background color for rows with the `draw-row` class to the `warning` color from the theme's palette.

2. We updated the `getRowClassName` function to handle the new condition:

```js
const getRowClassName = (params) => {
  const { outcome, event, amount, odds } = params.row;
  const [numerator, denominator] = odds.split("/");
  const winAmount = (amount * parseInt(numerator)) / parseInt(denominator);
  const profitAmount = winAmount - amount;

  if (outcome === event.outcome && profitAmount > 0) {
    return "win-row";
  } else if (outcome === event.outcome && profitAmount <= 0) {
    return "draw-row";
  } else {
    return "lose-row";
  }
};
```

- If the `outcome` and `event.outcome` match, and the `profitAmount` (calculated from the odds and bet amount) is greater than 0, the function returns `"win-row"`.
- If the `outcome` and `event.outcome` match, but the `profitAmount` is less than or equal to 0, the function returns `"draw-row"`.
- In all other cases (when the `outcome` and `event.outcome` don't match), the function returns `"lose-row"`.

With these changes, the grid will have the following row color conditions:

- Green background: If the bet outcome matches the event outcome, and the player won money based on the odds calculation.
- Yellow background: If the bet outcome matches the event outcome, but the player didn't win any money or lost money based on the odds calculation.
- Orange background: If the bet outcome doesn't match the event outcome (the player lost the bet).

The "Outcome" column will display the profit/loss amount, regardless of whether the bet outcome matched the event outcome or not.

Now add grid sorting feature. So that columns could be sorted based on value in it. Use standard grid functional if possible. If not - do not produce results and tell me
You can easily add sorting functionality to the columns in the `DataGrid` component using the `sortable` prop and the `sortModel` property in the `initialState`. Here's how you can modify the code:

```jsx
import { Typography, Card } from "@mui/material";
import { DataGrid } from "@mui/x-data-grid";
import { useBets } from "../hooks/useBets";
import { darken, lighten, styled } from "@mui/material/styles";

// ... (existing code)

export const BetHistory = () => {
  const { data: bets, isLoading: loadingBets } = useBets();
  if (loadingBets) return <Typography>Loading Bets...</Typography>;

  const columns = [
    {
      field: "eventName",
      headerName: "Event",
      flex: 1,
      sortable: true, // Add sortable prop
      valueGetter: (params) =>
        `${params.row.event.home || ""} vs ${params.row.event.away || ""}`,
    },
    {
      field: "odds",
      headerName: "Your Odds",
      sortable: true, // Add sortable prop
    },
    {
      field: "outcome",
      headerName: "You bet on",
      sortable: true, // Add sortable prop
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "result",
      headerName: "Outcome",
      sortable: true, // Add sortable prop
      valueGetter: (params) =>
        calculateOutcome(
          params.row.amount,
          params.row.odds,
          params.row.outcome,
          params.row.event.outcome
        ),
    },
    {
      field: "event.outcome",
      headerName: "Event outcome",
      sortable: true, // Add sortable prop
      valueGetter: (params) =>
        `${params.row.event.outcome || ""}`,
      valueFormatter: ({ value }) => conditionFormat[value],
    },
    {
      field: "placedAt",
      headerName: "Placed",
      sortable: true, // Add sortable prop
      flex: 1,
      valueFormatter: ({ value }) =>
        new Date(value).toLocaleString("en-GB", dateOptions),
    },
    {
      field: "betStatus",
      headerName: "Bet status",
      sortable: true, // Add sortable prop
      valueFormatter: ({ value }) => betStatusFormat[value],
    }
  ];

  return (
    <Card>
      <Typography variant="h5" sx={{ padding: 2 }}>
        Recent trades
      </Typography>
      <StyledDataGrid
        rows={bets}
        columns={columns}
        initialState={{
          pagination: {
            paginationModel: {
              pageSize: 5,
            },
          },
          sorting: {
            sortModel: [{ field: "placedAt", sort: "desc" }], // Initial sorting
          },
        }}
        getRowId={(row) => row?.betId}
        getRowClassName={getRowClassName}
        disableColumnSelector
        disableColumnFilter
        disableColumnMenu
        pageSizeOptions={[10]}
      />
    </Card>
  );
};

export default BetHistory;
```

Here are the changes:

1. We added the `sortable` prop to each column definition and set it to `true`. This enables sorting for that column.

2. In the `initialState` prop of the `DataGrid` component, we added a `sorting` object with a `sortModel` array. This sets the initial sorting for the grid. In this example, we sort by the `placedAt` field in descending order (`sort: "desc"`).

```js
initialState={{
  pagination: {
    paginationModel: {
      pageSize: 5,
    },
  },
  sorting: {
    sortModel: [{ field: "placedAt", sort: "desc" }],
  },
}}
```

With these changes, users will be able to sort the columns by clicking on the column headers. The initial sorting will be applied based on the `sortModel` defined in the `initialState`.

Note: You can also dynamically update the `sortModel` state to change the sorting programmatically, if needed.

I want to implement cool mui theme for this website. Where can i find cool mui themes?

Material-UI (MUI) does not officially provide pre-built themes, but there are several resources available where you can find and download cool MUI themes created by the community:

1. **MUI Treasury**: This is a community project that provides a collection of free and open-source Material-UI components, templates, and themes. You can find some cool MUI themes here: https://mui-treasury.com/themes/

2. **Minimal UI Kit**: This is a premium Material-UI kit that offers a clean and modern design with various UI components and themes. You can purchase it from the creator's website: https://minimal.themenate.net/

3. **React Material Kit**: This is a free Material-UI Kit that offers a modern and elegant design with various UI components and themes. You can download it from Creative Tim's website: https://www.creative-tim.com/product/material-kit-react

4. **GitHub Repositories**: Several developers and designers have created and shared their MUI themes on GitHub. You can search for "mui themes" on GitHub and explore the available repositories. Here's an example: https://github.com/mui/material-ui/tree/master/examples/gatsby

5. **CodePen**: CodePen is a great resource for finding code examples and UI snippets, including MUI themes. You can search for "mui themes" on CodePen and explore the available examples: https://codepen.io/search/pens?q=mui+themes

6. **CSS-Trick Articles**: CSS-Tricks is a popular website for web development resources, and they have published articles showcasing MUI themes and customizations. For example: https://css-tricks.com/building-a-hand-crafted-material-ui-theme/

7. **ThemeProvider**: MUI provides a `ThemeProvider` component that allows you to customize the default Material-UI theme with your own values. You can find documentation on how to create a custom MUI theme here: https://mui.com/material-ui/customization/theming/

When using a third-party theme, make sure to review the theme's code and documentation to understand how to integrate and customize it for your project. Additionally, keep in mind that some themes might be part of a larger UI kit or template, so you may need to purchase or obtain a license if required.

I will provide general app.jsx code as well as sportsbookappbar file that renders menu on a website. I need you to implement theme switch in menu block. This switch should change between light and dark themes of mui for the website. Switch should be standard mui switch as well. 

<code filename="App.jsx">
import diceImage from "./assets/dice.jpeg";
import bgImage from "./assets/background.jpg";
import headerImage from "./assets/header.jpg";
import { Outlet } from "react-router-dom";
import { Amplify } from "aws-amplify";
import { useEffect, useState } from "react";
import { useUser } from "./hooks/useUser";

import {
  Authenticator,
  ThemeProvider as AmplifyThemeProvider,
} from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
import useAmplifyTheme from "./hooks/useAmplifyTheme";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import {
  Typography,
  CssBaseline,
  Container,
  Drawer,
  Fab,
  Box,
  Stack,
  Collapse,
  Snackbar,
  Alert,
} from "@mui/material";
import SportsbookAppBar from "./components/SportsbookAppBar";
import SystemEvents from "./components/admin/SystemEvents";
import BetSlip from "./components/BetSlip";
import { BetSlipProvider } from "./providers/BetSlipProvider";
import { GlobalProvider } from "./providers/GlobalProvider";
import { useBetSlip } from "./providers/BetSlipContext";
import { useGlobal } from "./providers/GlobalContext";

import {
  AWS_REGION,
  AWS_USER_POOL_ID,
  AWS_USER_POOL_WEB_CLIENT_ID,
  AWS_APPSYNC_API_URL,
} from "./constants";

Amplify.configure({
  Auth: {
    region: AWS_REGION,
    userPoolId: AWS_USER_POOL_ID,
    userPoolWebClientId: AWS_USER_POOL_WEB_CLIENT_ID,
    mandatorySignIn: true,
  },
  aws_appsync_graphqlEndpoint: AWS_APPSYNC_API_URL,
  aws_appsync_region: AWS_REGION,
  aws_appsync_authenticationType: "AMAZON_COGNITO_USER_POOLS",
});

const primaryColor = "rgb(25, 118, 80)";
const secondaryColor = "#e53935";

const styles = {
  root: {
    backgroundSize: "cover",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    minHeight: "100vh",
    display: "flex",
    flexDirection: "column",
    backgroundImage: `url(${bgImage})`,
    color: "#ffffff", // Light text color
  },
};

const theme = createTheme({
  palette: {
    mode: "light", // Set the theme to dark mode
    primary: {
      main: primaryColor,
    },
    secondary: {
      main: secondaryColor,
    },
  },
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536,
      xxl: 1800,
    },
  },
});

function App({ user, signOut }) {
  const { showHub, setShowHub } = useBetSlip();
  const {
    bShowSnackbar,
    closeSnackbar,
    snackbarMessage,
    snackbarSeverity,
  } = useGlobal();
  const isLocked = useUser(user);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={styles.root}>
        <SportsbookAppBar user={user} signOut={signOut} isLocked={isLocked} />
        <Container disableGutters={true} maxWidth="xxl">
          <Snackbar
            open={bShowSnackbar}
            autoHideDuration={6000}
            onClose={closeSnackbar}
            anchorOrigin={{ vertical: "top", horizontal: "center" }}
          >
            <Alert
              onClose={closeSnackbar}
              severity={snackbarSeverity}
              sx={{ width: "100%" }}
            >
              {snackbarMessage}
            </Alert>
          </Snackbar>
          <Stack
            direction={"row"}
            sx={{ position: "relative", height: "calc(100vh - 64px)" }}
          >
            <Box
              sx={{
                height: "100%",
                paddingBottom: "50px",
                position: "relative",
                overflowY: "scroll",
                backgroundColor: "#eee", // Darker background color
              }}
            >
              <img src={headerImage} alt="dice" style={{
                width: "100%",
                height: "200px",
                objectFit: "cover",
                objectPosition: "center",
              }}/>
              <Outlet />
            </Box>
            <Box
              sx={{
                height: "100%",
                paddingRight: showHub ? 11 : 0,
                display: { lg: "flex", xs: "none" },
                backgroundColor: "#eee", // Darker background color
                overflowY: showHub ? "scroll" : "hidden",
              }}
            >
              <Collapse orientation="horizontal" in={showHub}>
                <Box
                  sx={{
                    width: "300px",
                    pr: "5px",
                    pl: "5px",
                    backgroundColor: "#eee", // Darker background color
                  }}
                >
                  <Box
                    sx={{
                      pt: "5px",
                      backgroundColor: "#eee", // Darker background color
                    }}
                  >
                    <BetSlip
                      onClose={() => setShowHub(false)}
                      isLocked={isLocked}
                    />
                  </Box>
                  <Box
                    sx={{
                      pt: "5px",
                      backgroundColor: "#eee", // Darker background color
                    }}
                  >
                    <SystemEvents />
                  </Box>
                </Box>
              </Collapse>
            </Box>
            {!showHub && (
              <Fab
                color="primary"
                variant="extended"
                aria-label="add"
                sx={{
                  width: 280,
                  position: "absolute",
                  bottom: 10,
                  right: 10,
                  backgroundColor: "#424242", // Darker background color
                  color: "#ffffff", // Light text color
                }}
                onClick={() => setShowHub(!showHub)}
              >
                Open Bet slip
              </Fab>
            )}
          </Stack>
        </Container>
      </Box>
      <Drawer
        sx={{ display: { lg: "none", xs: "block" } }}
        PaperProps={{ sx: { width: 350, backgroundColor: "#333333" } }} // Darker drawer background
        anchor="right"
        variant={"temporary"}
        open={showHub}
        onClose={() => setShowHub(false)}
      >
        <BetSlip onClose={() => setShowHub(false)} isLocked={isLocked} />
      </Drawer>
    </ThemeProvider>
  );
}

const components = {
  Header() {
    return (
      <Typography textAlign={"center"} variant={"h4"} mb={2}>
        AWS Event Driven Sportsbook
      </Typography>
    );
  },
};

const formFields = {
  signIn: {
    username: {
      placeholder: "Enter Your Email Here",
      isRequired: true,
      label: "Email Address",
    },
  },
  signUp: {
    username: {
      placeholder: "Enter Your Email Here",
      isRequired: true,
      label: "Email Address",
    },
  },
};

export default function AuthenticatedApp() {
  const amplifyTheme = useAmplifyTheme();
  return (
    <AmplifyThemeProvider amplifyTheme={theme}>
      <GlobalProvider>
        <BetSlipProvider>
          <Authenticator components={components} formFields={formFields}>
            {({ signOut, user }) => <App signOut={signOut} user={user} />}
          </Authenticator>
        </BetSlipProvider>
      </GlobalProvider>
    </AmplifyThemeProvider>
  );
}
</code>

<code filename="sportsbookappbar.jsx">
import { useEffect, useState } from "react";
import logo from "../assets/logo.png";

import EuroIcon from '@mui/icons-material/Euro';
import CurrencyPoundIcon from '@mui/icons-material/CurrencyPound';
import LogoutIcon from '@mui/icons-material/Logout'
import Settings from '@mui/icons-material/Settings';
import ListItemIcon from '@mui/material/ListItemIcon';
import AttachMoneyIcon from '@mui/icons-material/AttachMoney';
import AccountBalanceIcon from '@mui/icons-material/AccountBalance';
import MenuIcon from '@mui/icons-material/Menu';
import LockIcon from '@mui/icons-material/Lock';
import LockOpenIcon from '@mui/icons-material/LockOpen';

import { Auth } from "aws-amplify";
import {
  AppBar,
  Box,
  Divider,
  Button,
  Container,
  IconButton,
  MenuItem,
  Menu,
  Toolbar,
  Typography,
  Stack,
  Popover,
  Tooltip,
  Avatar,
} from "@mui/material";
import {
  usePopupState,
  bindTrigger,
  bindMenu,
} from "material-ui-popup-state/hooks";
import Wallet from "./Wallet";
import { useGlobal } from "../providers/GlobalContext";

import { Link, useLocation } from "react-router-dom";
import {
  useLockUser
} from "../hooks/useUser";

const pages = ["About", "Admin"];

function SportsbookAppBar({ user, signOut, isLocked }) {
  const [anchorElNav, setAnchorElNav] = useState(null);
  const { currencySymbol, toggleCurrency } = useGlobal();
  
  const { mutateAsync: lockUser } = useLockUser();
  const handleLockUser = (lockStatus) => lockUser({ data: { isLocked: lockStatus, userId: user.username  } });
  
  const popupState = usePopupState({ variant: "popover", popupId: "wallet" });
  const profileMenuState = usePopupState({ variant: "popover", popupId: "profile"});

  // const [anchorElProfile, setAnchorElProfile] = useState(null);
  // const profileMenuOpen = Boolean(anchorElProfile);

  const location = useLocation();
  useEffect(() => {
    setAnchorElNav(null);
  }, [location]);

  const handleOpenNavMenu = (event) => {
    setAnchorElNav(event.currentTarget);
  };
  const handleCloseNavMenu = () => {
    setAnchorElNav(null);
  };

  const accountSettings = () => {
    return (
      <Box>
        <Tooltip title="Account Settings">
          <IconButton 
           {...bindTrigger(profileMenuState)}
          >
            <Avatar />
          </IconButton>
        </Tooltip>
        <Menu
          {...bindMenu(profileMenuState)}
          PaperProps={{
            elevation: 0,
            sx: {
              overflow: 'visible',
              filter: 'drop-shadow(0px 2px 8px rgba(0,0,0,0.32))',
              mt: 1.5,
              '& .MuiAvatar-root': {
                width: 32,
                height: 32,
                ml: -0.5,
                mr: 1,
              },
              '&:before': {
                content: '""',
                display: 'block',
                position: 'absolute',
                top: 0,
                right: 14,
                width: 10,
                height: 10,
                bgcolor: 'background.paper',
                transform: 'translateY(-50%) rotate(45deg)',
                zIndex: 0,
              },
            },
          }}
          transformOrigin={{ horizontal: 'right', vertical: 'top' }}
          anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
        >
          <MenuItem sx={{ mr: 2, display: { xs: "none", md: "flex" } }}>
            <Avatar /> {user.attributes.email}
          </MenuItem>
          <Divider />
          <MenuItem onClick={handleLock}>
            <ListItemIcon>
              {isLocked ?
                <LockOpenIcon /> : <LockIcon />
              }
            </ListItemIcon>
            {isLocked ? "Unlock Account" : "Lock Account"}
          </MenuItem>
          <MenuItem onClick={toggleCurrency}>
            <ListItemIcon>
              {currencySymbol == '£' &&
                <CurrencyPoundIcon />
              }
              {currencySymbol == '€' &&
                <EuroIcon />
              }
              {currencySymbol == '$' &&
                <AttachMoneyIcon />
              }
            </ListItemIcon>
            Switch currency
          </MenuItem>
          <MenuItem onClick={handleCloseNavMenu}>
            <ListItemIcon>
              <Settings fontSize="small" />
            </ListItemIcon>
            Settings
          </MenuItem>
          <MenuItem onClick={signOut}>
            <ListItemIcon>
              <LogoutIcon />
            </ListItemIcon>
            Logout
          </MenuItem>
        </Menu>
      </Box>
    );
  }

  //function that sets user "locked" attribute to provided boolean value
  const handleLock = async () => {
    handleLockUser(!isLocked);
    console.log("User lock status:"+ !isLocked);
  };
  
  return (
    <AppBar position="sticky" color="primary">
      <Container maxWidth="xxl">
        <Toolbar disableGutters>
          <img src={logo} width={48} alt="sportsbook logo" />
          <Typography
            variant="h6"
            noWrap
            component={Link}
            to="/"
            sx={{
              ml: 2,
              mr: 2,
              mb: 0.5,
              display: { xs: "none", md: "flex" },
              fontFamily: "monospace",
              fontWeight: 700,
              letterSpacing: ".2rem",
              color: "inherit",
              textDecoration: "none",
            }}
          >
            AWS Event Driven Sportsbook
          </Typography>

          <Box sx={{ flexGrow: 1, display: { xs: "flex", md: "none" } }}>
            <IconButton
              size="large"
              aria-label="account of current user"
              aria-controls="menu-appbar"
              aria-haspopup="true"
              onClick={handleOpenNavMenu}
              color="inherit"
            >
              <MenuIcon />
            </IconButton>
            <Menu
              id="menu-appbar"
              anchorEl={anchorElNav}
              anchorOrigin={{
                vertical: "bottom",
                horizontal: "left",
              }}
              keepMounted
              transformOrigin={{
                vertical: "top",
                horizontal: "left",
              }}
              open={Boolean(anchorElNav)}
              onClose={handleCloseNavMenu}
              sx={{
                display: { xs: "block", md: "none" },
              }}
            >
              {pages.map((page) => (
                <MenuItem key={page} component={Link} to={page}>
                  <Typography
                    textAlign="center"
                    sx={{ textTransform: "capitalize", textDecoration: "none" }}
                  >
                    {page}
                  </Typography>
                </MenuItem>
              ))}
            </Menu>
          </Box>
          <Typography
            variant="h5"
            noWrap
            component={Link}
            to="/"
            sx={{
              mr: 2,
              display: { xs: "flex", md: "none" },
              flexGrow: 1,
              fontFamily: "monospace",
              fontWeight: 600,
              letterSpacing: ".2rem",
              color: "inherit",
              textDecoration: "none",
            }}
          >
            Sportsbook
          </Typography>
          <Stack
            direction="row"
            spacing={2}
            sx={{ flexGrow: 1, display: { xs: "none", md: "flex" } }}
          >
            {pages.map((page) => (
              <Button
                key={page}
                component={Link}
                to={page}
                sx={{ color: "white", display: "block" }}
              >
                {page}
              </Button>
            ))}
          </Stack>
          <Typography sx={{ mr: 2, display: { xs: "none", md: "flex" } }}>
            {user.attributes.email}
          </Typography>
          
          <IconButton color="inherit" {...bindTrigger(popupState)}>
            <AccountBalanceIcon />
          </IconButton>
          <Popover
            {...bindMenu(popupState)}
            anchorOrigin={{
              vertical: "bottom",
              horizontal: "right",
            }}
            transformOrigin={{
              vertical: "top",
              horizontal: "right",
            }}
          >
            <Box width={300}>
              <Wallet isLocked={isLocked} />
            </Box>
          </Popover>
          
          {accountSettings()}

        </Toolbar>
      </Container>
    </AppBar>
  );
}
export default SportsbookAppBar;

</code>
To implement a theme switch in the `SportsbookAppBar` component, we can use the `useContext` hook from React to access the theme context provided by the `ThemeProvider` component in the `App.jsx` file. We can then create a state to manage the theme mode (light or dark) and update the theme mode accordingly when the switch is toggled.

Here's how you can modify the `SportsbookAppBar` component:

```jsx
import { useContext, useState } from "react";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import { Switch } from "@mui/material";

// ... (import statements)

const primaryColor = "rgb(25, 118, 80)";
const secondaryColor = "#e53935";

function SportsbookAppBar({ user, signOut, isLocked }) {
  // ... (existing code)

  const [isDarkMode, setIsDarkMode] = useState(false);

  const handleThemeChange = () => {
    setIsDarkMode(!isDarkMode);
  };

  const theme = createTheme({
    palette: {
      mode: isDarkMode ? "dark" : "light",
      primary: {
        main: primaryColor,
      },
      secondary: {
        main: secondaryColor,
      },
    },
    breakpoints: {
      values: {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536,
        xxl: 1800,
      },
    },
  });

  return (
    <ThemeProvider theme={theme}>
      <AppBar position="sticky" color="primary">
        <Container maxWidth="xxl">
          <Toolbar disableGutters>
            {/* ... (existing content) */}
            <Switch
              checked={isDarkMode}
              onChange={handleThemeChange}
              color="default"
            />
          </Toolbar>
        </Container>
      </AppBar>
    </ThemeProvider>
  );
}

export default SportsbookAppBar;
```

Here are the changes:

1. We imported `useContext` from React and the `Switch` component from `@mui/material`.
2. We defined a new state `isDarkMode` and a function `handleThemeChange` to toggle the theme mode.
3. We moved the `createTheme` function inside the `SportsbookAppBar` component, and we're now using the `isDarkMode` state to determine the `mode` of the theme (`"dark"` or `"light"`).
4. We wrapped the `AppBar` component with the `ThemeProvider` and passed the dynamically created theme object.
5. We added a `Switch` component to the `Toolbar`, where the `checked` prop is bound to the `isDarkMode` state, and the `onChange` event is bound to the `handleThemeChange` function.

With these changes, the `SportsbookAppBar` component will now have a switch that allows users to toggle between light and dark themes. When the switch is toggled, the `isDarkMode` state will be updated, triggering a re-render of the component with the new theme.

Note: This implementation assumes that you want to apply the theme change only to the `SportsbookAppBar` component. If you want to apply the theme change globally to the entire application, you should move the `ThemeProvider` and the theme creation logic to the `App.jsx` file instead.

I do want to apply theme globally, so move the theming logic to app.jsx. Also, add menu item in account settings dropdown menu to click and change theme.

Sure, here's the updated code with the theme switching logic moved to `App.jsx` and a menu item added to the account settings dropdown menu in `SportsbookAppBar`:

**App.jsx**:

```jsx
import { useState } from "react";
import { ThemeProvider, createTheme } from "@mui/material/styles";
// ... (other imports)

const primaryColor = "rgb(25, 118, 80)";
const secondaryColor = "#e53935";

function App({ user, signOut }) {
  const [isDarkMode, setIsDarkMode] = useState(false);

  const handleThemeChange = () => {
    setIsDarkMode(!isDarkMode);
  };

  const theme = createTheme({
    palette: {
      mode: isDarkMode ? "dark" : "light",
      primary: {
        main: primaryColor,
      },
      secondary: {
        main: secondaryColor,
      },
    },
    breakpoints: {
      values: {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536,
        xxl: 1800,
      },
    },
  });

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={styles.root}>
        <SportsbookAppBar
          user={user}
          signOut={signOut}
          isLocked={isLocked}
          handleThemeChange={handleThemeChange}
          isDarkMode={isDarkMode}
        />
        {/* ... (rest of the code) */}
      </Box>
    </ThemeProvider>
  );
}

// ... (rest of the code)
```

**SportsbookAppBar.jsx**:

```jsx
import { MenuItem, ListItemIcon, Switch } from "@mui/material";
import Brightness4Icon from "@mui/icons-material/Brightness4";
import Brightness7Icon from "@mui/icons-material/Brightness7";

// ... (other imports)

function SportsbookAppBar({ user, signOut, isLocked, handleThemeChange, isDarkMode }) {
  // ... (existing code)

  const accountSettings = () => {
    return (
      <Box>
        <Tooltip title="Account Settings">
          <IconButton {...bindTrigger(profileMenuState)}>
            <Avatar />
          </IconButton>
        </Tooltip>
        <Menu
          {...bindMenu(profileMenuState)}
          PaperProps={{
            elevation: 0,
            sx: {
              overflow: "visible",
              filter: "drop-shadow(0px 2px 8px rgba(0,0,0,0.32))",
              mt: 1.5,
              "& .MuiAvatar-root": {
                width: 32,
                height: 32,
                ml: -0.5,
                mr: 1,
              },
              "&:before": {
                content: '""',
                display: "block",
                position: "absolute",
                top: 0,
                right: 14,
                width: 10,
                height: 10,
                bgcolor: "background.paper",
                transform: "translateY(-50%) rotate(45deg)",
                zIndex: 0,
              },
            },
          }}
          transformOrigin={{ horizontal: "right", vertical: "top" }}
          anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
        >
          <MenuItem sx={{ mr: 2, display: { xs: "none", md: "flex" } }}>
            <Avatar /> {user.attributes.email}
          </MenuItem>
          <Divider />
          <MenuItem onClick={handleLock}>
            <ListItemIcon>
              {isLocked ? <LockOpenIcon /> : <LockIcon />}
            </ListItemIcon>
            {isLocked ? "Unlock Account" : "Lock Account"}
          </MenuItem>
          <MenuItem onClick={toggleCurrency}>
            <ListItemIcon>
              {currencySymbol == "£" && <CurrencyPoundIcon />}
              {currencySymbol == "€" && <EuroIcon />}
              {currencySymbol == "$" && <AttachMoneyIcon />}
            </ListItemIcon>
            Switch currency
          </MenuItem>
          <MenuItem onClick={handleThemeChange}>
            <ListItemIcon>
              {isDarkMode ? <Brightness7Icon /> : <Brightness4Icon />}
            </ListItemIcon>
            {isDarkMode ? "Light Mode" : "Dark Mode"}
          </MenuItem>
          <MenuItem onClick={handleCloseNavMenu}>
            <ListItemIcon>
              <Settings fontSize="small" />
            </ListItemIcon>
            Settings
          </MenuItem>
          <MenuItem onClick={signOut}>
            <ListItemIcon>
              <LogoutIcon />
            </ListItemIcon>
            Logout
          </MenuItem>
        </Menu>
      </Box>
    );
  };

  // ... (rest of the code)
}
```

Here are the changes:

1. In `App.jsx`, we moved the theme creation logic and the `handleThemeChange` function inside the `App` component.
2. We're now passing the `handleThemeChange` function and the `isDarkMode` state as props to the `SportsbookAppBar` component.
3. In `SportsbookAppBar.jsx`, we imported the `MenuItem`, `ListItemIcon`, `Switch`, `Brightness4Icon`, and `Brightness7Icon` components from `@mui/material` and `@mui/icons-material`.
4. Inside the `accountSettings` function, we added a new `MenuItem` that calls the `handleThemeChange` function when clicked. This menu item displays the appropriate icon and text based on the current theme mode (`isDarkMode`).

With these changes, the theme switching functionality is now global and controlled by the `App` component. The `SportsbookAppBar` component now has a menu item in the account settings dropdown menu that allows the user to switch between light and dark themes by clicking on it.

Note: Make sure to adjust the styling of the components as needed to ensure a consistent appearance across both light and dark themes.

Then theme is initialized in App() function, i get an error "theme is not defined". How do fix it?
The error "theme is not defined" occurs because the `theme` variable is defined inside the `App` function, but it's not accessible outside of that function scope.

To fix this issue, you can move the theme creation logic and the `handleThemeChange` function outside of the `App` component, making them separate functions that can be called within the `App` component.

Here's how you can update the `App.jsx` file:

```jsx
import { useState } from "react";
import { ThemeProvider, createTheme } from "@mui/material/styles";
// ... (other imports)

const primaryColor = "rgb(25, 118, 80)";
const secondaryColor = "#e53935";

const getTheme = (isDarkMode) =>
  createTheme({
    palette: {
      mode: isDarkMode ? "dark" : "light",
      primary: {
        main: primaryColor,
      },
      secondary: {
        main: secondaryColor,
      },
    },
    breakpoints: {
      values: {
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536,
        xxl: 1800,
      },
    },
  });

function App({ user, signOut }) {
  const [isDarkMode, setIsDarkMode] = useState(false);

  const handleThemeChange = () => {
    setIsDarkMode(!isDarkMode);
  };

  const theme = getTheme(isDarkMode);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Box sx={styles.root}>
        <SportsbookAppBar
          user={user}
          signOut={signOut}
          isLocked={isLocked}
          handleThemeChange={handleThemeChange}
          isDarkMode={isDarkMode}
        />
        {/* ... (rest of the code) */}
      </Box>
    </ThemeProvider>
  );
}

// ... (rest of the code)
```

In this updated code:

1. We moved the `createTheme` logic into a separate function called `getTheme`, which takes the `isDarkMode` state as a parameter and returns the appropriate theme object.
2. Inside the `App` component, we're now calling the `getTheme` function with the `isDarkMode` state to get the current theme object, which is then passed to the `ThemeProvider` component.

By moving the theme creation logic outside of the `App` component, the `theme` variable is now accessible within the component's scope, resolving the "theme is not defined" error.

This approach separates the theme creation logic from the component rendering logic, making the code more modular and easier to maintain.

When theme is switched to dark mode i can barely see buttons. I want default color for buttons to be brighter when using dark theme. How can i do that?

To change the default button color for the dark theme, you can customize the MUI theme object by overriding the button styles. Here's how you can do it:

1. First, create a separate file (e.g., `theme.js`) where you can define the custom theme. In this file, you'll import the `createTheme` function from `@mui/material/styles` and define your custom theme object.

```jsx
// theme.js
import { createTheme } from "@mui/material/styles";

const primaryColor = "rgb(25, 118, 80)";
const secondaryColor = "#e53935";

const theme = createTheme({
  palette: {
    mode: "dark",
    primary: {
      main: primaryColor,
    },
    secondary: {
      main: secondaryColor,
    },
  },
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536,
      xxl: 1800,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          color: "#fff", // Set the default button text color for dark mode
        },
      },
    },
  },
});

export default theme;
```

2. In the `components` section of the theme object, you can override the styles for specific MUI components. In this case, we're overriding the styles for the `MuiButton` component.

3. Within the `MuiButton` object, we define the `styleOverrides` property, which allows us to override specific styles for the button component.

4. Inside `styleOverrides`, we target the `root` class, which represents the root element of the button component. Here, we set the `color` property to `#fff` (white), which will make the button text white in dark mode.

5. Next, in your `App.jsx` file, import the custom theme from the `theme.js` file:

```jsx
// App.jsx
import theme from "./theme";

// ... (other imports)

function App({ user, signOut }) {
  // ... (existing code)

  return (
    <ThemeProvider theme={theme}>
      {/* ... (rest of the code) */}
    </ThemeProvider>
  );
}

// ... (rest of the code)
```

6. Finally, remove the `getTheme` function and the `handleThemeChange` logic from `App.jsx`, as you're now using a static theme object defined in `theme.js`.

With these changes, the buttons in the dark theme will have a white text color, making them more visible against the dark background. You can further customize the button styles by modifying the `styleOverrides` object in the `theme.js` file.

If you want to support both light and dark modes, you can create separate theme objects for each mode and conditionally pass the appropriate theme object to the `ThemeProvider` based on the user's preference (e.g., using a state variable or a user setting).